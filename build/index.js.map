{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/capnp-ts/lib/constants.js","webpack:///./node_modules/capnp-ts/lib/errors.js","webpack:///./node_modules/capnp-ts/lib/index.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/arena.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/index.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js","webpack:///./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js","webpack:///./node_modules/capnp-ts/lib/serialization/index.js","webpack:///./node_modules/capnp-ts/lib/serialization/list-element-size.js","webpack:///./node_modules/capnp-ts/lib/serialization/mask.js","webpack:///./node_modules/capnp-ts/lib/serialization/message.js","webpack:///./node_modules/capnp-ts/lib/serialization/object-size.js","webpack:///./node_modules/capnp-ts/lib/serialization/packing.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/data-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/data.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/index.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/interface.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/orphan.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/pointer.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/struct.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/text-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/text.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/void-list.js","webpack:///./node_modules/capnp-ts/lib/serialization/pointers/void.js","webpack:///./node_modules/capnp-ts/lib/serialization/segment.js","webpack:///./node_modules/capnp-ts/lib/types/index.js","webpack:///./node_modules/capnp-ts/lib/types/int64.js","webpack:///./node_modules/capnp-ts/lib/types/uint64.js","webpack:///./node_modules/capnp-ts/lib/util.js","webpack:///./node_modules/capnp-ts/node_modules/debug/src/browser.js","webpack:///./node_modules/capnp-ts/node_modules/debug/src/debug.js","webpack:///./node_modules/ms/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./src/date.capnp.ts","webpack:///./src/index.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;AClBA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,CAAC,0DAA0D;;AAE3D;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA,wDAAwD,6EAA6E;AACrI;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAA2D;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,2EAA2E;AACpI;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,eAAe,qCAAqC;AACpD;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA,+DAA+D,0CAA0C;AACzG;AACA,2DAA2D;AAC3D;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,0CAA0C,mBAAmB;AAC7D;AACA,wGAAwG;AACxG;AACA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,EAAE;AACnB;AACA,uDAAuD,kCAAkC;AACzF;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,EAAE;AACnB;AACA,wDAAwD,mCAAmC;AAC3F;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA,mDAAmD,4BAA4B;AAC/E;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA,yDAAyD,kCAAkC;AAC3F,8CAA8C,6CAA6C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,4BAA4B,eAAe;AAC3C,mCAAmC,uBAAuB;AAC1D;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,2CAA2C,EAAE;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oEAAoE,EAAE;AAC7H,gFAAgF,yBAAyB,EAAE;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjVA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,YAAY;AACzB;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACjRA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,2BAA2B,EAAE;AAC3F;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC/PA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;;AAEjE;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA,8DAA8D;AAC9D;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA,WAAW,EAAE;AACb,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,WAAW,8DAA8D;AACpF;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,WAAW,gBAAgB;AAC3B;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACtxBA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAA4D;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC7xBA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,6CAA6C;AACnE,iBAAiB,OAAO;AACxB;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;;AAEA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;AC5VA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;;;;;;;;;;;ACpLA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;AACA,WAAW,OAAO;AAClB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,0BAA0B;AAC1E;AACA,gDAAgD,8BAA8B;AAC9E;AACA,gDAAgD,sCAAsC;AACtF;AACA,gDAAgD,4CAA4C;AAC5F;;AAEA;;;;;;;;;;;;AC7VA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACzMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvLtC;AAAA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA,mCAAmC,oCAAoC;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;;AAEA;AACA,aAAa,6BAA6B,0BAA0B,aAAa,EAAE,qBAAqB;AACxG,gBAAgB,qDAAqD,oEAAoE,aAAa,EAAE;AACxJ,sBAAsB,sBAAsB,qBAAqB,GAAG;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,kCAAkC,SAAS;AAC3C,kCAAkC,WAAW,UAAU;AACvD,yCAAyC,cAAc;AACvD;AACA,6GAA6G,OAAO,UAAU;AAC9H,gFAAgF,iBAAiB,OAAO;AACxG,wDAAwD,gBAAgB,QAAQ,OAAO;AACvF,8CAA8C,gBAAgB,gBAAgB,OAAO;AACrF;AACA,iCAAiC;AACjC;AACA;AACA,SAAS,YAAY,aAAa,OAAO,EAAE,UAAU,WAAW;AAChE,mCAAmC,SAAS;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM,gBAAgB;AACzC;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sFAAsF,aAAa,EAAE;AACtH,sBAAsB,gCAAgC,qCAAqC,0CAA0C,EAAE,EAAE,GAAG;AAC5I,2BAA2B,MAAM,eAAe,EAAE,YAAY,oBAAoB,EAAE;AACpF,sBAAsB,oGAAoG;AAC1H,6BAA6B,uBAAuB;AACpD,4BAA4B,wBAAwB;AACpD,2BAA2B,yDAAyD;AACpF;;AAEA;AACA;AACA,iBAAiB,4CAA4C,SAAS,EAAE,qDAAqD,aAAa,EAAE;AAC5I,yBAAyB,6BAA6B,oBAAoB,gDAAgD,gBAAgB,EAAE,KAAK;AACjJ;;AAEA;AACA;AACA;AACA,2GAA2G,sFAAsF,aAAa,EAAE;AAChN,sBAAsB,8BAA8B,gDAAgD,uDAAuD,EAAE,EAAE,GAAG;AAClK,4CAA4C,sCAAsC,UAAU,oBAAoB,EAAE,EAAE,UAAU;AAC9H;;AAEA;AACA,gCAAgC,uCAAuC,aAAa,EAAE,EAAE,OAAO,kBAAkB;AACjH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;;;;;;;;;;;;;;;;ACzLA;AAAA;AAAA;;GAEG;;;;;;;;;;;AAEH,oBAAoB;AAEc;AAC0B;AACrD,IAAM,YAAY,GAAG,kBAAkB,CAAC;AAC/C;IAA0B,wBAAG;IAA7B;;IASA,CAAC;IAPG,sBAAO,GAAP,cAAoB,OAAO,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACnD,sBAAO,GAAP,UAAQ,KAAa,IAAU,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC9D,uBAAQ,GAAR,cAAqB,OAAO,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACpD,uBAAQ,GAAR,UAAS,KAAa,IAAU,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC/D,qBAAM,GAAN,cAAmB,OAAO,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAClD,qBAAM,GAAN,UAAO,KAAa,IAAU,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7D,uBAAQ,GAAR,cAAqB,OAAO,OAAO,GAAG,iBAAM,QAAQ,WAAE,CAAC,CAAC,CAAC;IAPzC,WAAM,GAAG,EAAE,WAAW,EAAE,MAAM,EAAE,EAAE,EAAE,kBAAkB,EAAE,IAAI,EAAE,IAAI,mDAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IAQlG,WAAC;CAAA,CATyB,+CAAG,GAS5B;AATgB;AAUjB;IAA6B,2BAAG;IAAhC;;IAUA,CAAC;IAPG,4BAAU,GAAV,UAAW,KAAqC,IAAU,+CAAG,CAAC,KAAK,CAAC,KAAK,EAAE,+CAAG,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACtG,6BAAW,GAAX,cAAgD,OAAO,+CAAG,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC;IACrF,0BAAQ,GAAR,cAA+B,OAAO,+CAAG,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IAC7E,0BAAQ,GAAR,cAAsB,OAAO,CAAC,+CAAG,CAAC,MAAM,CAAC,+CAAG,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACpE,2BAAS,GAAT,UAAU,MAAc,IAAsB,OAAO,+CAAG,CAAC,QAAQ,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACrG,0BAAQ,GAAR,UAAS,KAAuB,IAAU,+CAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,+CAAG,CAAC,UAAU,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACzF,0BAAQ,GAAR,cAAqB,OAAO,UAAU,GAAG,iBAAM,QAAQ,WAAE,CAAC,CAAC,CAAC;IAR5C,cAAM,GAAG,EAAE,WAAW,EAAE,SAAS,EAAE,EAAE,EAAE,kBAAkB,EAAE,IAAI,EAAE,IAAI,mDAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;IASrG,cAAC;CAAA,CAV4B,+CAAG,GAU/B;AAVmB;AAWpB,OAAO,CAAC,MAAM,GAAG,sDAAmB,CAAC,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;AC9B3C;AAAA;;;;;;;;;;;GAWG;AAC+B;AACW;AAGvC,qBAAsB,MAAmB;IAC3C,IAAM,OAAO,GAAG,IAAI,gDAAa,CAAC,MAAM,CAAC,CAAC;IAC1C,OAAO,OAAO,CAAC,OAAO,CAAC,gDAAI,CAAC,CAAC;AACjC,CAAC;AAED,IAAI,MAAM,GAAG,IAAI,WAAW,CAAC,gDAAI,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAC9D,IAAI,OAAO,GAAG,IAAI,gDAAa,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC;AAEpD,IAAI,IAAI,GAAG,gDAAa,CAAC,QAAQ,CAAC,gDAAI,EAAE,OAAO,CAAC,CAAC;AAGjD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;AAClB,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC;AACjB,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;AAEf,cAAc;AACd,gCAAgC;AAChC,aAAa;AAEb,uDAAuD;AACvD,IAAI,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,EAAE,CAAC;AAE/D,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;AAExB,IAAI,OAAO,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,CAAC;AACpC,IAAI,QAAQ,GAAG,IAAI,gDAAa,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC;AACtD,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC;AACvB,IAAI,GAAG,GAAG,gDAAa,CAAC,QAAQ,CAAC,mDAAO,EAAE,QAAQ,CAAC,CAAC;AAEpD,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;AACjB,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;AAExB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;AAE7C,IAAI,EAAE,GAAG,GAAG,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,EAAE;AAClD,IAAM,GAAG,GAAG,IAAI,gDAAa,CAAC,EAAE,CAAC,CAAC;AAElC,iEAAiE","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Perform some bit gymnastics to determine the native endian format.\nvar tmpWord = new DataView(new ArrayBuffer(8));\n(new Uint16Array(tmpWord.buffer))[0] = 0x0102;\n/** Default size (in bytes) for newly allocated segments. */\nexports.DEFAULT_BUFFER_SIZE = 4096;\nexports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB\n/**\n * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it\n * is decremented as pointers are dereferenced.\n */\nexports.DEFAULT_DEPTH_LIMIT = 64;\n/**\n * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain\n * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the\n * depth limit.\n *\n * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the\n * message's traversal limit gets decremented each time.\n */\nexports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB\n/**\n * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's\n * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent\n * reallocating and wasted memory to a minimum.\n *\n * Smaller numbers would save memory at the expense of CPU time.\n */\nexports.GROWTH_FACTOR = 1.5;\n/** A bitmask applied to obtain the size of a list pointer. */\nexports.LIST_SIZE_MASK = 0x00000007;\n/** Maximum number of bytes to dump at once when dumping array buffers to string. */\nexports.MAX_BUFFER_DUMP_BYTES = 8192;\n/** The maximum value for a 32-bit integer. */\nexports.MAX_INT32 = 0x7fffffff;\n/** The maximum value for a 32-bit unsigned integer. */\nexports.MAX_UINT32 = 0xffffffff;\n/** The largest integer that can be precisely represented in JavaScript. */\nexports.MAX_SAFE_INTEGER = 9007199254740991;\n/** Maximum limit on the number of segments in a message stream. */\nexports.MAX_STREAM_SEGMENTS = 512;\n/** The smallest integer that can be precisely represented in JavaScript. */\nexports.MIN_SAFE_INTEGER = -9007199254740991;\n/** Minimum growth increment for a SingleSegmentArena. */\nexports.MIN_SINGLE_SEGMENT_GROWTH = 4096;\n/**\n * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful\n * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for\n * these operations is _slightly_ faster.\n */\nexports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;\n/**\n * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed\n * message before the span is terminated.\n *\n * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher\n * value may help with messages that contain a ton of text/data.\n *\n * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.\n */\nexports.PACK_SPAN_THRESHOLD = 2;\n/**\n * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy\n * operation will throw an error.\n */\nexports.POINTER_COPY_LIMIT = 32;\n/** A bitmask for looking up the double-far flag on a far pointer. */\nexports.POINTER_DOUBLE_FAR_MASK = 0x00000004;\n/** A bitmask for looking up the pointer type. */\nexports.POINTER_TYPE_MASK = 0x00000003;\n/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */\nexports.VAL32 = 0x100000000;\n/** The maximum value allowed for depth traversal limits. */\nexports.MAX_DEPTH = exports.MAX_INT32;\n/** The maximum byte length for a single segment. */\nexports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;\n\n//# sourceMappingURL=constants.js.map\n","\"use strict\";\n/**\n * This file contains all the error strings used in the library. Also contains silliness.\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar trace = debug_1.default('capnp:errors');\ntrace('load');\nfunction assertNever(n) {\n    throw new Error(exports.INVARIANT_UNREACHABLE_CODE + (\" (never block hit with: \" + n + \")\"));\n}\nexports.assertNever = assertNever;\n// Invariant violations (sometimes known as \"precondition failed\").\n//\n// All right, hold up the brakes. This is a serious 1 === 0 WHAT THE FAILURE moment here. Tell the SO's you won't be\n// home for dinner.\nexports.INVARIANT_UNREACHABLE_CODE = 'CAPNP-TS000 Unreachable code detected.';\n// Message errors.\n//\n// Now who told you it would be a good idea to fuzz the inputs? You just made the program sad.\nexports.MSG_INVALID_FRAME_HEADER = 'CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap\\'n Proto message?';\nexports.MSG_NO_SEGMENTS_IN_ARENA = 'CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.';\nexports.MSG_PACK_NOT_WORD_ALIGNED = 'CAPNP-TS003 Attempted to pack a message that was not word-aligned.';\nexports.MSG_SEGMENT_OUT_OF_BOUNDS = 'CAPNP-TS004 Segment ID %X is out of bounds for message %s.';\nexports.MSG_SEGMENT_TOO_SMALL = 'CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).';\n// Used for methods that are not yet implemented.\n//\n// My bad. I'll get to it. Eventually.\nexports.NOT_IMPLEMENTED = 'CAPNP-TS006 %s is not implemented.';\n// Pointer-related errors.\n//\n// Look, this is probably the hardest part of the code. Cut some slack here! You probably found a bug.\nexports.PTR_ADOPT_COMPOSITE_STRUCT = 'CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).';\nexports.PTR_ADOPT_WRONG_MESSAGE = 'CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.';\nexports.PTR_ALREADY_ADOPTED = 'CAPNP-TS009 Attempted to adopt %s more than once.';\nexports.PTR_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS010 Attempted to set a composite list without providing a composite element size.';\nexports.PTR_DEPTH_LIMIT_EXCEEDED = 'CAPNP-TS011 Nesting depth limit exceeded for %s.';\nexports.PTR_DISOWN_COMPOSITE_STRUCT = 'CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).';\nexports.PTR_INIT_COMPOSITE_STRUCT = 'CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).';\nexports.PTR_INIT_NON_GROUP = 'CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.';\nexports.PTR_INVALID_FAR_TARGET = 'CAPNP-TS015 Target of a far pointer (%s) is another far pointer.';\nexports.PTR_INVALID_LIST_SIZE = 'CAPNP-TS016 Invalid list element size: %x.';\nexports.PTR_INVALID_POINTER_TYPE = 'CAPNP-TS017 Invalid pointer type: %x.';\nexports.PTR_INVALID_UNION_ACCESS = 'CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).';\nexports.PTR_OFFSET_OUT_OF_BOUNDS = 'CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.';\nexports.PTR_STRUCT_DATA_OUT_OF_BOUNDS = 'CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).';\nexports.PTR_STRUCT_POINTER_OUT_OF_BOUNDS = 'CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).';\nexports.PTR_TRAVERSAL_LIMIT_EXCEEDED = 'CAPNP-TS022 Traversal limit exceeded! Slow down! %s';\nexports.PTR_WRONG_LIST_TYPE = 'CAPNP-TS023 Cannot convert %s to a %s list.';\nexports.PTR_WRONG_POINTER_TYPE = 'CAPNP-TS024 Attempted to convert pointer %s to a %s type.';\nexports.PTR_WRONG_COMPOSITE_DATA_SIZE = 'CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).';\nexports.PTR_WRONG_COMPOSITE_PTR_SIZE = 'CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).';\nexports.PTR_WRONG_STRUCT_DATA_SIZE = 'CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).';\nexports.PTR_WRONG_STRUCT_PTR_SIZE = 'CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).';\n// Custom error messages for the built-in `RangeError` class.\n//\n// You don't get a witty comment with these.\nexports.RANGE_INT32_OVERFLOW = 'CAPNP-TS029 32-bit signed integer overflow detected.';\nexports.RANGE_INT64_UNDERFLOW = 'CAPNP-TS030 Buffer is not large enough to hold a word.';\nexports.RANGE_INVALID_UTF8 = 'CAPNP-TS031 Invalid UTF-8 code sequence detected.';\nexports.RANGE_SIZE_OVERFLOW = \"CAPNP-TS032 Size %x exceeds maximum \" + constants_1.MAX_SEGMENT_LENGTH.toString(16) + \".\";\nexports.RANGE_UINT32_OVERFLOW = 'CAPNP-TS033 32-bit unsigned integer overflow detected.';\n// Segment-related errors.\n//\n// These suck. Deal with it.\nexports.SEG_BUFFER_NOT_ALLOCATED = 'CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.';\nexports.SEG_GET_NON_ZERO_SINGLE = 'CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.';\nexports.SEG_ID_OUT_OF_BOUNDS = 'CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).';\nexports.SEG_NOT_WORD_ALIGNED = 'CAPNP-TS037 Segment buffer length %d is not a multiple of 8.';\nexports.SEG_REPLACEMENT_BUFFER_TOO_SMALL = 'CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.';\nexports.SEG_SIZE_OVERFLOW = \"CAPNP-TS039 Requested size %x exceeds maximum value (\" + constants_1.MAX_SEGMENT_LENGTH + \").\";\n// Custom error messages for the built-in `TypeError` class.\n//\n// If it looks like a duck, quacks like an elephant, and has hooves for feet, it's probably JavaScript.\nexports.TYPE_COMPOSITE_SIZE_UNDEFINED = 'CAPNP-TS040 Must provide a composite element size for composite list pointers.';\nexports.TYPE_GET_GENERIC_LIST = 'CAPNP-TS041 Attempted to call get() on a generic list.';\nexports.TYPE_SET_GENERIC_LIST = 'CAPNP-TS042 Attempted to call set() on a generic list.';\n\n//# sourceMappingURL=errors.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar serialization_1 = require(\"./serialization\");\nexports.ListElementSize = serialization_1.ListElementSize;\nexports.Message = serialization_1.Message;\nexports.ObjectSize = serialization_1.ObjectSize;\nexports.AnyPointerList = serialization_1.AnyPointerList;\nexports.BoolList = serialization_1.BoolList;\nexports.CompositeList = serialization_1.CompositeList;\nexports.Data = serialization_1.Data;\nexports.DataList = serialization_1.DataList;\nexports.Float32List = serialization_1.Float32List;\nexports.Float64List = serialization_1.Float64List;\nexports.Int16List = serialization_1.Int16List;\nexports.Int32List = serialization_1.Int32List;\nexports.Int64List = serialization_1.Int64List;\nexports.Int8List = serialization_1.Int8List;\nexports.Interface = serialization_1.Interface;\nexports.InterfaceList = serialization_1.InterfaceList;\nexports.List = serialization_1.List;\nexports.Orphan = serialization_1.Orphan;\nexports.PointerList = serialization_1.PointerList;\nexports.PointerType = serialization_1.PointerType;\nexports.Pointer = serialization_1.Pointer;\nexports.Struct = serialization_1.Struct;\nexports.Text = serialization_1.Text;\nexports.TextList = serialization_1.TextList;\nexports.Uint16List = serialization_1.Uint16List;\nexports.Uint32List = serialization_1.Uint32List;\nexports.Uint64List = serialization_1.Uint64List;\nexports.Uint8List = serialization_1.Uint8List;\nexports.VoidList = serialization_1.VoidList;\nexports.Void = serialization_1.Void;\nexports.getBitMask = serialization_1.getBitMask;\nexports.getFloat32Mask = serialization_1.getFloat32Mask;\nexports.getFloat64Mask = serialization_1.getFloat64Mask;\nexports.getInt16Mask = serialization_1.getInt16Mask;\nexports.getInt32Mask = serialization_1.getInt32Mask;\nexports.getInt64Mask = serialization_1.getInt64Mask;\nexports.getInt8Mask = serialization_1.getInt8Mask;\nexports.getUint16Mask = serialization_1.getUint16Mask;\nexports.getUint32Mask = serialization_1.getUint32Mask;\nexports.getUint64Mask = serialization_1.getUint64Mask;\nexports.getUint8Mask = serialization_1.getUint8Mask;\nvar types_1 = require(\"./types\");\nexports.Int64 = types_1.Int64;\nexports.Uint64 = types_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default('capnp:serialization:arena:arena-allocation-result');\ntrace('load');\nvar ArenaAllocationResult = /** @class */ (function () {\n    function ArenaAllocationResult(id, buffer) {\n        this.id = id;\n        this.buffer = buffer;\n        trace('new', this);\n    }\n    return ArenaAllocationResult;\n}());\nexports.ArenaAllocationResult = ArenaAllocationResult;\n\n//# sourceMappingURL=arena-allocation-result.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ArenaKind;\n(function (ArenaKind) {\n    ArenaKind[ArenaKind[\"SINGLE_SEGMENT\"] = 0] = \"SINGLE_SEGMENT\";\n    ArenaKind[ArenaKind[\"MULTI_SEGMENT\"] = 1] = \"MULTI_SEGMENT\";\n})(ArenaKind = exports.ArenaKind || (exports.ArenaKind = {}));\n\n//# sourceMappingURL=arena-kind.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nvar trace = debug_1.default('capnp:arena');\ntrace('load');\nvar Arena = /** @class */ (function () {\n    function Arena() {\n    }\n    Arena.allocate = allocate;\n    Arena.getBuffer = getBuffer;\n    Arena.getNumSegments = getNumSegments;\n    return Arena;\n}());\nexports.Arena = Arena;\nfunction allocate(minSize, segments, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.allocate = allocate;\nfunction getBuffer(id, a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(a) {\n    switch (a.kind) {\n        case arena_kind_1.ArenaKind.MULTI_SEGMENT:\n            return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);\n        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:\n            return single_segment_arena_1.SingleSegmentArena.getNumSegments();\n        default:\n            return errors_1.assertNever(a);\n    }\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arena_1 = require(\"./arena\");\nexports.Arena = arena_1.Arena;\nvar arena_kind_1 = require(\"./arena-kind\");\nexports.ArenaKind = arena_kind_1.ArenaKind;\nvar multi_segment_arena_1 = require(\"./multi-segment-arena\");\nexports.MultiSegmentArena = multi_segment_arena_1.MultiSegmentArena;\nvar single_segment_arena_1 = require(\"./single-segment-arena\");\nexports.SingleSegmentArena = single_segment_arena_1.SingleSegmentArena;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default('capnp:arena:multi');\ntrace('load');\nvar MultiSegmentArena = /** @class */ (function () {\n    function MultiSegmentArena(buffers) {\n        if (buffers === void 0) { buffers = []; }\n        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;\n        this.buffers = buffers;\n        trace('new %s', this);\n    }\n    MultiSegmentArena.prototype.toString = function () { return util_1.format('MultiSegmentArena_segments:%d', getNumSegments(this)); };\n    MultiSegmentArena.allocate = allocate;\n    MultiSegmentArena.getBuffer = getBuffer;\n    MultiSegmentArena.getNumSegments = getNumSegments;\n    return MultiSegmentArena;\n}());\nexports.MultiSegmentArena = MultiSegmentArena;\nfunction allocate(minSize, m) {\n    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));\n    m.buffers.push(b);\n    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, m) {\n    if (id < 0 || id >= m.buffers.length)\n        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));\n    return m.buffers[id];\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments(m) {\n    return m.buffers.length;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=multi-segment-arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar arena_allocation_result_1 = require(\"./arena-allocation-result\");\nvar arena_kind_1 = require(\"./arena-kind\");\nvar trace = debug_1.default('capnp:arena:single');\ntrace('load');\nvar SingleSegmentArena = /** @class */ (function () {\n    function SingleSegmentArena(buffer) {\n        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }\n        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;\n        if ((buffer.byteLength & 7) !== 0)\n            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));\n        this.buffer = buffer;\n        trace('new %s', this);\n    }\n    SingleSegmentArena.prototype.toString = function () { return util_1.format('SingleSegmentArena_len:%x', this.buffer.byteLength); };\n    SingleSegmentArena.allocate = allocate;\n    SingleSegmentArena.getBuffer = getBuffer;\n    SingleSegmentArena.getNumSegments = getNumSegments;\n    return SingleSegmentArena;\n}());\nexports.SingleSegmentArena = SingleSegmentArena;\nfunction allocate(minSize, segments, s) {\n    trace('Allocating %x bytes for segment 0 in %s.', minSize, s);\n    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;\n    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {\n        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;\n    }\n    else {\n        minSize = util_1.padToWord(minSize);\n    }\n    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);\n    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word\n    // at a time.\n    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));\n    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);\n}\nexports.allocate = allocate;\nfunction getBuffer(id, s) {\n    if (id !== 0)\n        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));\n    return s.buffer;\n}\nexports.getBuffer = getBuffer;\nfunction getNumSegments() {\n    return 1;\n}\nexports.getNumSegments = getNumSegments;\n\n//# sourceMappingURL=single-segment-arena.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./mask\"), exports);\nvar list_element_size_1 = require(\"./list-element-size\");\nexports.ListElementSize = list_element_size_1.ListElementSize;\nvar message_1 = require(\"./message\");\nexports.Message = message_1.Message;\nvar object_size_1 = require(\"./object-size\");\nexports.ObjectSize = object_size_1.ObjectSize;\ntslib_1.__exportStar(require(\"./pointers\"), exports);\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ListElementSize;\n(function (ListElementSize) {\n    ListElementSize[ListElementSize[\"VOID\"] = 0] = \"VOID\";\n    ListElementSize[ListElementSize[\"BIT\"] = 1] = \"BIT\";\n    ListElementSize[ListElementSize[\"BYTE\"] = 2] = \"BYTE\";\n    ListElementSize[ListElementSize[\"BYTE_2\"] = 3] = \"BYTE_2\";\n    ListElementSize[ListElementSize[\"BYTE_4\"] = 4] = \"BYTE_4\";\n    ListElementSize[ListElementSize[\"BYTE_8\"] = 5] = \"BYTE_8\";\n    ListElementSize[ListElementSize[\"POINTER\"] = 6] = \"POINTER\";\n    ListElementSize[ListElementSize[\"COMPOSITE\"] = 7] = \"COMPOSITE\";\n})(ListElementSize = exports.ListElementSize || (exports.ListElementSize = {}));\nexports.ListElementOffset = [\n    0,\n    0.125,\n    1,\n    2,\n    4,\n    8,\n    8,\n    NaN,\n];\n\n//# sourceMappingURL=list-element-size.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _makePrimitiveMaskFn(byteLength, setter) {\n    return function (x) {\n        var dv = new DataView(new ArrayBuffer(byteLength));\n        setter.call(dv, 0, x, true);\n        return dv;\n    };\n}\n/* tslint:disable:no-unsafe-any */\nexports.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);\nexports.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);\nexports.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);\nexports.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);\nexports.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);\nexports.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);\nexports.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);\nexports.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);\n/* tslint:enable:no-unsafe-any */\nfunction getBitMask(value, bitOffset) {\n    var dv = new DataView(new ArrayBuffer(1));\n    if (!value)\n        return dv;\n    dv.setUint8(0, 1 << bitOffset % 8);\n    return dv;\n}\nexports.getBitMask = getBitMask;\nfunction getInt64Mask(x) {\n    return x.toDataView();\n}\nexports.getInt64Mask = getInt64Mask;\nfunction getUint64Mask(x) {\n    return x.toDataView();\n}\nexports.getUint64Mask = getUint64Mask;\n\n//# sourceMappingURL=mask.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar arena_1 = require(\"./arena\");\nvar packing_1 = require(\"./packing\");\nvar pointers_1 = require(\"./pointers\");\nvar segment_1 = require(\"./segment\");\nvar pointer_1 = require(\"./pointers/pointer\");\nvar struct_1 = require(\"./pointers/struct\");\nvar trace = debug_1.default('capnp:message');\ntrace('load');\nvar Message = /** @class */ (function () {\n    /**\n     * A Cap'n Proto message.\n     *\n     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer\n     * directly and everything will be fine. If not, your message will potentially be initialized with random memory\n     * contents!\n     *\n     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer\n     * to read from.\n     *\n     * @constructor {Message}\n     *\n     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.\n     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the\n     * root pointer; it will expand as you go. This is a reasonable choice for most messages.\n     *\n     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted\n     * as-is.\n     *\n     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source\n     * buffer; beware of the potential performance cost!\n     *\n     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be\n     * unpacked.\n     *\n     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without\n     * a framing header.\n     *\n     */\n    function Message(src, packed, singleSegment) {\n        if (packed === void 0) { packed = true; }\n        if (singleSegment === void 0) { singleSegment = false; }\n        this._capnp = initMessage(src, packed, singleSegment);\n        if (src && !isAnyArena(src))\n            preallocateSegments(this);\n        trace('new %s', this);\n    }\n    Message.prototype.allocateSegment = function (byteLength) { return allocateSegment(byteLength, this); };\n    /**\n     * Create a pretty-printed string dump of this message; incredibly useful for debugging.\n     *\n     * WARNING: Do not call this method on large messages!\n     *\n     * @returns {string} A big steaming pile of pretty hex digits.\n     */\n    Message.prototype.dump = function () { return dump(this); };\n    /**\n     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not\n     * overwrite existing data.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} A struct representing the root of the message.\n     */\n    Message.prototype.getRoot = function (RootStruct) { return getRoot(RootStruct, this); };\n    /**\n     * Get a segment by its id.\n     *\n     * This will lazily allocate the first segment if it doesn't already exist.\n     *\n     * @param {number} id The segment id.\n     * @returns {Segment} The requested segment.\n     */\n    Message.prototype.getSegment = function (id) { return getSegment(id, this); };\n    /**\n     * Initialize a new message using the provided struct type as the root.\n     *\n     * @template T\n     * @param {StructCtor<T>} RootStruct The struct type to use as the root.\n     * @returns {T} An initialized struct pointing to the root of the message.\n     */\n    Message.prototype.initRoot = function (RootStruct) { return initRoot(RootStruct, this); };\n    /**\n     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header\n     * containing information about the following segment data.\n     *\n     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.\n     */\n    Message.prototype.toArrayBuffer = function () { return toArrayBuffer(this); };\n    /**\n     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to\n     * use if you're sending the message over a network link or other slow I/O interface where size matters.\n     *\n     * @returns {ArrayBuffer} A packed message.\n     */\n    Message.prototype.toPackedArrayBuffer = function () { return toPackedArrayBuffer(this); };\n    Message.prototype.toString = function () { return \"Message_arena:\" + this._capnp.arena; };\n    Message.allocateSegment = allocateSegment;\n    Message.dump = dump;\n    Message.getRoot = getRoot;\n    Message.getSegment = getSegment;\n    Message.initRoot = initRoot;\n    Message.toArrayBuffer = toArrayBuffer;\n    Message.toPackedArrayBuffer = toPackedArrayBuffer;\n    return Message;\n}());\nexports.Message = Message;\nfunction initMessage(src, packed, singleSegment) {\n    if (packed === void 0) { packed = true; }\n    if (singleSegment === void 0) { singleSegment = false; }\n    if (src === undefined) {\n        return { arena: new arena_1.SingleSegmentArena(), segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    }\n    if (isAnyArena(src))\n        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };\n    var buf = src;\n    if (isArrayBufferView(buf))\n        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    if (packed)\n        buf = packing_1.unpack(buf);\n    if (singleSegment) {\n        return {\n            arena: new arena_1.SingleSegmentArena(buf),\n            segments: [],\n            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n        };\n    }\n    return {\n        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),\n        segments: [],\n        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,\n    };\n}\nexports.initMessage = initMessage;\n/**\n * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in\n * the message.\n *\n * This method is not typically called directly, but can be useful in certain cases.\n *\n * @static\n * @param {ArrayBuffer} message An unpacked message with a framing header.\n * @returns {ArrayBuffer[]} An array of buffers containing the segment data.\n */\nfunction getFramedSegments(message) {\n    var dv = new DataView(message);\n    var segmentCount = dv.getUint32(0, true) + 1;\n    var segments = new Array(segmentCount);\n    trace('reading %d framed segments from stream', segmentCount);\n    var byteOffset = 4 + segmentCount * 4;\n    byteOffset += byteOffset % 8;\n    if (byteOffset + segmentCount * 4 > message.byteLength)\n        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n    for (var i = 0; i < segmentCount; i++) {\n        var byteLength = dv.getUint32(4 + i * 4, true) * 8;\n        if (byteOffset + byteLength > message.byteLength)\n            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);\n        segments[i] = message.slice(byteOffset, byteOffset + byteLength);\n        byteOffset += byteLength;\n    }\n    return segments;\n}\nexports.getFramedSegments = getFramedSegments;\n/**\n * This method is called on messages that were constructed with existing data to prepopulate the segments array with\n * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.\n *\n * Technically speaking, the message's segments will be \"full\" after calling this function. Calling this on your own\n * may void your warranty.\n *\n * @param {Message} m The message to allocate.\n * @returns {void}\n */\nfunction preallocateSegments(m) {\n    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n    if (numSegments < 1)\n        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);\n    m._capnp.segments = new Array(numSegments);\n    for (var i = 0; i < numSegments; i++) {\n        // Set up each segment so that they're fully allocated to the extents of the existing buffers.\n        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);\n        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);\n        m._capnp.segments[i] = segment;\n    }\n}\nexports.preallocateSegments = preallocateSegments;\nfunction isArrayBufferView(src) {\n    return src.byteOffset !== undefined;\n}\nfunction isAnyArena(o) {\n    return o.kind !== undefined;\n}\nfunction allocateSegment(byteLength, m) {\n    trace('allocating %x bytes for %s', byteLength, m);\n    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);\n    var s;\n    if (res.id === m._capnp.segments.length) {\n        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical\n        // reason for segments to be created out of order.\n        s = new segment_1.Segment(res.id, m, res.buffer);\n        trace('adding new segment %s', s);\n        m._capnp.segments.push(s);\n    }\n    else if (res.id < 0 || res.id > m._capnp.segments.length) {\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));\n    }\n    else {\n        s = m._capnp.segments[res.id];\n        trace('replacing segment %s with buffer (len:%d)', s, res.buffer.byteLength);\n        s.replaceBuffer(res.buffer);\n    }\n    return s;\n}\nexports.allocateSegment = allocateSegment;\nfunction dump(m) {\n    var r = '';\n    if (m._capnp.segments.length === 0)\n        return '================\\nNo Segments\\n================\\n';\n    for (var i = 0; i < m._capnp.segments.length; i++) {\n        r += \"================\\nSegment #\" + i + \"\\n================\\n\";\n        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;\n        var b = new Uint8Array(buffer, 0, byteLength);\n        r += util_1.dumpBuffer(b);\n    }\n    return r;\n}\nexports.dump = dump;\nfunction getRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    pointer_1.validate(pointers_1.PointerType.STRUCT, root);\n    var ts = pointer_1.getTargetStructSize(root);\n    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.\n    // If not a shallow copy of the struct contents needs to be made before returning.\n    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength\n        || ts.pointerLength < RootStruct._capnp.size.pointerLength) {\n        trace('need to resize root struct %s', root);\n        struct_1.resize(RootStruct._capnp.size, root);\n    }\n    return root;\n}\nexports.getRoot = getRoot;\nfunction getSegment(id, m) {\n    var segmentLength = m._capnp.segments.length;\n    if (id === 0 && segmentLength === 0) {\n        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room\n        // for the root pointer.\n        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);\n        if (arenaSegments === 0) {\n            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);\n        }\n        else {\n            // Okay, the arena already has a buffer we can use. This is totally fine.\n            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));\n        }\n        if (!m._capnp.segments[0].hasCapacity(8))\n            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);\n        // This will leave room for the root pointer.\n        m._capnp.segments[0].allocate(8);\n        return m._capnp.segments[0];\n    }\n    if (id < 0 || id >= segmentLength)\n        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));\n    return m._capnp.segments[id];\n}\nexports.getSegment = getSegment;\nfunction initRoot(RootStruct, m) {\n    var root = new RootStruct(m.getSegment(0), 0);\n    struct_1.initStruct(RootStruct._capnp.size, root);\n    trace('Initialized root pointer %s for %s.', root, m);\n    return root;\n}\nexports.initRoot = initRoot;\nfunction toArrayBuffer(m) {\n    var streamFrame = getStreamFrame(m);\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        getSegment(0, m);\n    var segments = m._capnp.segments;\n    // Add space for the stream framing.\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        var segmentLength = util_1.padToWord(s.byteLength);\n        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);\n        o += segmentLength;\n    });\n    return out.buffer;\n}\nexports.toArrayBuffer = toArrayBuffer;\nfunction toPackedArrayBuffer(m) {\n    var streamFrame = packing_1.pack(getStreamFrame(m));\n    // Make sure the first segment is allocated.\n    if (m._capnp.segments.length === 0)\n        m.getSegment(0);\n    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy\n    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the\n    // intermediate array can be avoided altogether that's even better!\n    var segments = m._capnp.segments.map(function (s) { return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength)); });\n    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);\n    var out = new Uint8Array(new ArrayBuffer(totalLength));\n    var o = streamFrame.byteLength;\n    out.set(new Uint8Array(streamFrame));\n    segments.forEach(function (s) {\n        out.set(new Uint8Array(s), o);\n        o += s.byteLength;\n    });\n    return out.buffer;\n}\nexports.toPackedArrayBuffer = toPackedArrayBuffer;\nfunction getStreamFrame(m) {\n    var length = m._capnp.segments.length;\n    if (length === 0) {\n        // Don't bother allocating the first segment, just return a single zero word for the frame header.\n        return new Float64Array(1).buffer;\n    }\n    var frameLength = 4 + length * 4 + (1 - length % 2) * 4;\n    var out = new DataView(new ArrayBuffer(frameLength));\n    trace('Writing message stream frame with segment count: %d.', length);\n    out.setUint32(0, length - 1, true);\n    m._capnp.segments.forEach(function (s, i) {\n        trace('Message segment %d word count: %d.', s.id, s.byteLength / 8);\n        out.setUint32(i * 4 + 4, s.byteLength / 8, true);\n    });\n    return out.buffer;\n}\nexports.getStreamFrame = getStreamFrame;\n\n//# sourceMappingURL=message.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar _ = require(\"../util\");\nvar trace = debug_1.default('capnp:object-size');\ntrace('load');\n/**\n * A simple object that describes the size of a struct.\n *\n * @export\n * @class ObjectSize\n */\nvar ObjectSize = /** @class */ (function () {\n    function ObjectSize(dataByteLength, pointerCount) {\n        this.dataByteLength = dataByteLength;\n        this.pointerLength = pointerCount;\n    }\n    ObjectSize.prototype.toString = function () {\n        return _.format('ObjectSize_dw:%d,pc:%d', getDataWordLength(this), this.pointerLength);\n    };\n    return ObjectSize;\n}());\nexports.ObjectSize = ObjectSize;\nfunction getByteLength(o) {\n    return o.dataByteLength + o.pointerLength * 8;\n}\nexports.getByteLength = getByteLength;\nfunction getDataWordLength(o) {\n    return o.dataByteLength / 8;\n}\nexports.getDataWordLength = getDataWordLength;\nfunction getWordLength(o) {\n    return o.dataByteLength / 8 + o.pointerLength;\n}\nexports.getWordLength = getWordLength;\nfunction padToWord(o) {\n    return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);\n}\nexports.padToWord = padToWord;\n\n//# sourceMappingURL=object-size.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\n/**\n * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte\n * while computing the size of a packed message.\n *\n * WARNING: Using this with floating point numbers will void your warranty.\n *\n * @param {number} x A real integer.\n * @returns {number} The hamming weight (integer).\n */\nfunction getHammingWeight(x) {\n    // Thanks, HACKMEM!\n    var w = x - ((x >> 1) & 0x55555555);\n    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);\n    return ((w + (w >> 4) & 0x0f0f0f0f) * 0x01010101) >> 24;\n}\nexports.getHammingWeight = getHammingWeight;\n/**\n * Compute the tag byte from the 8 bytes of a 64-bit word.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The tag byte.\n */\nfunction getTagByte(a, b, c, d, e, f, g, h) {\n    // Yes, it's pretty. Don't touch it.\n    return (a === 0 ? 0 : 1) |\n        (b === 0 ? 0 : 2) |\n        (c === 0 ? 0 : 4) |\n        (d === 0 ? 0 : 8) |\n        (e === 0 ? 0 : 16) |\n        (f === 0 ? 0 : 32) |\n        (g === 0 ? 0 : 64) |\n        (h === 0 ? 0 : 128);\n}\nexports.getTagByte = getTagByte;\n/**\n * Efficiently calculate the length of a packed Cap'n Proto message.\n *\n * @export\n * @param {ArrayBuffer} packed The packed message.\n * @returns {number} The length of the unpacked message in bytes.\n */\nfunction getUnpackedByteLength(packed) {\n    var p = new Uint8Array(packed);\n    var wordLength = 0;\n    var lastTag = 0x77;\n    for (var i = 0; i < p.byteLength;) {\n        var tag = p[i];\n        if (lastTag === 0 /* ZERO */) {\n            wordLength += tag;\n            i++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            wordLength += tag;\n            i += tag * 8 + 1;\n            lastTag = 0x77;\n        }\n        else {\n            wordLength++;\n            i += getHammingWeight(tag) + 1;\n            lastTag = tag;\n        }\n    }\n    return wordLength * 8;\n}\nexports.getUnpackedByteLength = getUnpackedByteLength;\n/**\n * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.\n *\n * @param {byte} a The first byte.\n * @param {byte} b The second byte.\n * @param {byte} c The third byte.\n * @param {byte} d The fourth byte.\n * @param {byte} e The fifth byte.\n * @param {byte} f The sixth byte.\n * @param {byte} g The seventh byte.\n * @param {byte} h The eighth byte (phew!).\n * @returns {number} The number of these bytes that are zero.\n */\nfunction getZeroByteCount(a, b, c, d, e, f, g, h) {\n    return (a === 0 ? 1 : 0) +\n        (b === 0 ? 1 : 0) +\n        (c === 0 ? 1 : 0) +\n        (d === 0 ? 1 : 0) +\n        (e === 0 ? 1 : 0) +\n        (f === 0 ? 1 : 0) +\n        (g === 0 ? 1 : 0) +\n        (h === 0 ? 1 : 0);\n}\nexports.getZeroByteCount = getZeroByteCount;\n/**\n * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which\n * are common in idiomatic Cap'n Proto messages) into a compact form.\n *\n * For stream-framed messages this is called once for the frame header and once again for each segment in the message.\n *\n * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.\n * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each\n * packed byte until the packing is complete).\n *\n * @export\n * @param {ArrayBuffer} unpacked The message to pack.\n * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.\n * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.\n * @returns {ArrayBuffer} A packed version of the message.\n */\nfunction pack(unpacked, byteOffset, byteLength) {\n    if (byteOffset === void 0) { byteOffset = 0; }\n    if (unpacked.byteLength % 8 !== 0)\n        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);\n    var src = new Uint8Array(unpacked, byteOffset, byteLength);\n    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.\n    var dst = [];\n    /* Just have to be sure it's neither ZERO nor SPAN. */\n    var lastTag = 0x77;\n    /** This is where we need to remember to write the SPAN tag (0xff). */\n    var spanTagOffset = NaN;\n    /** How many words have been copied during the current span. */\n    var spanWordLength = 0;\n    /**\n     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.\n     */\n    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {\n        /** Read in the entire word. Yes, this feels silly but it's fast! */\n        var a = src[srcByteOffset];\n        var b = src[srcByteOffset + 1];\n        var c = src[srcByteOffset + 2];\n        var d = src[srcByteOffset + 3];\n        var e = src[srcByteOffset + 4];\n        var f = src[srcByteOffset + 5];\n        var g = src[srcByteOffset + 6];\n        var h = src[srcByteOffset + 7];\n        var tag = getTagByte(a, b, c, d, e, f, g, h);\n        /** If this is true we'll skip the normal word write logic after the switch statement. */\n        var skipWriteWord = true;\n        switch (lastTag) {\n            case 0 /* ZERO */:\n                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.\n                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {\n                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.\n                    dst.push(spanWordLength);\n                    spanWordLength = 0;\n                    skipWriteWord = false;\n                }\n                else {\n                    // Kay, let's quickly inc this and go.\n                    spanWordLength++;\n                }\n                break;\n            case 255 /* SPAN */:\n                // We're writing a span of nonzero words.\n                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);\n                // See if we need to bail now.\n                spanThreshold -= zeroCount;\n                if (spanThreshold <= 0 || spanWordLength >= 0xff) {\n                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.\n                    dst[spanTagOffset] = spanWordLength;\n                    spanWordLength = 0;\n                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;\n                    // We have to write this word normally.\n                    skipWriteWord = false;\n                }\n                else {\n                    // Just write this word verbatim.\n                    dst.push(a, b, c, d, e, f, g, h);\n                    spanWordLength++;\n                }\n                break;\n            default:\n                // Didn't get a special tag last time, let's write this as normal.\n                skipWriteWord = false;\n                break;\n        }\n        // A goto is fast, idk why people keep hatin'.\n        if (skipWriteWord)\n            continue;\n        dst.push(tag);\n        lastTag = tag;\n        if (a !== 0)\n            dst.push(a);\n        if (b !== 0)\n            dst.push(b);\n        if (c !== 0)\n            dst.push(c);\n        if (d !== 0)\n            dst.push(d);\n        if (e !== 0)\n            dst.push(e);\n        if (f !== 0)\n            dst.push(f);\n        if (g !== 0)\n            dst.push(g);\n        if (h !== 0)\n            dst.push(h);\n        // Record the span tag offset if needed, making sure to actually leave room for it.\n        if (tag === 255 /* SPAN */) {\n            spanTagOffset = dst.length;\n            dst.push(0);\n        }\n    }\n    // We're done. If we were writing a span let's finish it.\n    if (lastTag === 0 /* ZERO */) {\n        dst.push(spanWordLength);\n    }\n    else if (lastTag === 255 /* SPAN */) {\n        dst[spanTagOffset] = spanWordLength;\n    }\n    return new Uint8Array(dst).buffer;\n}\nexports.pack = pack;\n/**\n * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.\n *\n * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and\n * runs considerably more efficiently.\n *\n * @export\n * @param {ArrayBuffer} packed An array buffer containing the packed message.\n * @returns {ArrayBuffer} The unpacked message.\n */\nfunction unpack(packed) {\n    // We have no choice but to read the packed buffer one byte at a time.\n    var src = new Uint8Array(packed);\n    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));\n    /** The last tag byte that we've seen - it starts at a \"neutral\" value. */\n    var lastTag = 0x77;\n    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {\n        var tag = src[srcByteOffset];\n        if (lastTag === 0 /* ZERO */) {\n            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.\n            dstByteOffset += tag * 8;\n            srcByteOffset++;\n            lastTag = 0x77;\n        }\n        else if (lastTag === 255 /* SPAN */) {\n            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.\n            var spanByteLength = tag * 8;\n            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);\n            dstByteOffset += spanByteLength;\n            srcByteOffset += 1 + spanByteLength;\n            lastTag = 0x77;\n        }\n        else {\n            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.\n            srcByteOffset++;\n            for (var i = 1; i <= 128; i <<= 1) {\n                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).\n                if ((tag & i) !== 0)\n                    dst[dstByteOffset] = src[srcByteOffset++];\n                dstByteOffset++;\n            }\n            lastTag = tag;\n        }\n    }\n    return dst.buffer;\n}\nexports.unpack = unpack;\n\n//# sourceMappingURL=packing.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_1 = require(\"./pointer\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);\n\n//# sourceMappingURL=any-pointer-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar BoolList = /** @class */ (function (_super) {\n    tslib_1.__extends(BoolList, _super);\n    function BoolList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BoolList.prototype.get = function (index) {\n        var bitMask = 1 << index % 8;\n        var byteOffset = index >>> 3;\n        var c = pointer_1.getContent(this);\n        var v = c.segment.getUint8(c.byteOffset + byteOffset);\n        return (v & bitMask) !== 0;\n    };\n    BoolList.prototype.set = function (index, value) {\n        var bitMask = 1 << index % 8;\n        var c = pointer_1.getContent(this);\n        var byteOffset = c.byteOffset + (index >>> 3);\n        var v = c.segment.getUint8(byteOffset);\n        c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);\n    };\n    BoolList.prototype.toString = function () {\n        return \"Bool_\" + _super.prototype.toString.call(this);\n    };\n    BoolList._capnp = {\n        displayName: 'List<boolean>',\n        size: list_element_size_1.ListElementSize.BIT,\n    };\n    return BoolList;\n}(list_1.List));\nexports.BoolList = BoolList;\n\n//# sourceMappingURL=bool-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction CompositeList(CompositeClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                return new CompositeClass(this.segment, this.byteOffset, this._capnp.depthLimit - 1, index);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Composite_\" + _super.prototype.toString.call(this) + \",cls:\" + CompositeClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            compositeSize: CompositeClass._capnp.size,\n            displayName: \"List<\" + CompositeClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.COMPOSITE,\n        },\n        _a;\n    var _a;\n}\nexports.CompositeList = CompositeList;\n\n//# sourceMappingURL=composite-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_1 = require(\"./data\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.DataList = pointer_list_1.PointerList(data_1.Data);\n\n//# sourceMappingURL=data-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:data');\ntrace('load');\n/**\n * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and\n * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.\n *\n * @export\n * @class Data\n * @extends {List<number>}\n */\nvar Data = /** @class */ (function (_super) {\n    tslib_1.__extends(Data, _super);\n    function Data() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Data.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return this._fromPointerUnchecked(pointer);\n    };\n    Data._fromPointerUnchecked = function (pointer) {\n        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n    };\n    /**\n     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the\n     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.\n     *\n     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.\n     * @returns {void}\n     */\n    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that\n    // buffer data.\n    Data.prototype.copyBuffer = function (src) {\n        var c = pointer_1.getContent(this);\n        var dstLength = this.getLength();\n        var srcLength = src.byteLength;\n        var i = src instanceof ArrayBuffer\n            ? new Uint8Array(src)\n            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));\n        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n        o.set(i);\n        if (dstLength > srcLength) {\n            trace('Zeroing out remaining %d bytes after copy into %s.', dstLength - srcLength, this);\n            o.fill(0, srcLength, dstLength);\n        }\n        else if (dstLength < srcLength) {\n            trace('Truncated %d bytes from source buffer while copying to %s.', srcLength - dstLength, this);\n        }\n    };\n    /**\n     * Read a byte from the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to read.\n     * @returns {number} The byte value.\n     */\n    Data.prototype.get = function (byteOffset) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + byteOffset);\n    };\n    /**\n     * Write a byte at the specified offset.\n     *\n     * @param {number} byteOffset The byte offset to set.\n     * @param {number} value The byte value to set.\n     * @returns {void}\n     */\n    Data.prototype.set = function (byteOffset, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + byteOffset, value);\n    };\n    /**\n     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.\n     *\n     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.\n     *\n     * @returns {ArrayBuffer} A copy of this data buffer.\n     */\n    Data.prototype.toArrayBuffer = function () {\n        var c = pointer_1.getContent(this);\n        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());\n    };\n    /**\n     * Convert this Data pointer to a DataView representing the pointer's contents.\n     *\n     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the\n     * DataView or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toDataView = function () {\n        var c = pointer_1.getContent(this);\n        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    Data.prototype.toString = function () {\n        return \"Data_\" + _super.prototype.toString.call(this);\n    };\n    /**\n     * Convert this Data pointer to a Uint8Array representing the pointer's contents.\n     *\n     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the\n     * Uint8Array or else BAD THINGS.\n     *\n     * @returns {DataView} A live reference to the underlying buffer.\n     */\n    Data.prototype.toUint8Array = function () {\n        var c = pointer_1.getContent(this);\n        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());\n    };\n    return Data;\n}(list_1.List));\nexports.Data = Data;\n\n//# sourceMappingURL=data.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float32List, _super);\n    function Float32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat32(c.byteOffset + index * 4);\n    };\n    Float32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat32(c.byteOffset + index * 4, value);\n    };\n    Float32List.prototype.toString = function () {\n        return \"Float32_\" + _super.prototype.toString.call(this);\n    };\n    Float32List._capnp = {\n        displayName: 'List<Float32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Float32List;\n}(list_1.List));\nexports.Float32List = Float32List;\n\n//# sourceMappingURL=float32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Float64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Float64List, _super);\n    function Float64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Float64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getFloat64(c.byteOffset + index * 8);\n    };\n    Float64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setFloat64(c.byteOffset + index * 8, value);\n    };\n    Float64List.prototype.toString = function () {\n        return \"Float64_\" + _super.prototype.toString.call(this);\n    };\n    Float64List._capnp = {\n        displayName: 'List<Float64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Float64List;\n}(list_1.List));\nexports.Float64List = Float64List;\n\n//# sourceMappingURL=float64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar any_pointer_list_1 = require(\"./any-pointer-list\");\nexports.AnyPointerList = any_pointer_list_1.AnyPointerList;\nvar bool_list_1 = require(\"./bool-list\");\nexports.BoolList = bool_list_1.BoolList;\nvar composite_list_1 = require(\"./composite-list\");\nexports.CompositeList = composite_list_1.CompositeList;\nvar data_1 = require(\"./data\");\nexports.Data = data_1.Data;\nvar data_list_1 = require(\"./data-list\");\nexports.DataList = data_list_1.DataList;\nvar float32_list_1 = require(\"./float32-list\");\nexports.Float32List = float32_list_1.Float32List;\nvar float64_list_1 = require(\"./float64-list\");\nexports.Float64List = float64_list_1.Float64List;\nvar int8_list_1 = require(\"./int8-list\");\nexports.Int8List = int8_list_1.Int8List;\nvar int16_list_1 = require(\"./int16-list\");\nexports.Int16List = int16_list_1.Int16List;\nvar int32_list_1 = require(\"./int32-list\");\nexports.Int32List = int32_list_1.Int32List;\nvar int64_list_1 = require(\"./int64-list\");\nexports.Int64List = int64_list_1.Int64List;\nvar interface_1 = require(\"./interface\");\nexports.Interface = interface_1.Interface;\nvar interface_list_1 = require(\"./interface-list\");\nexports.InterfaceList = interface_list_1.InterfaceList;\nvar list_1 = require(\"./list\");\nexports.List = list_1.List;\nvar orphan_1 = require(\"./orphan\");\nexports.Orphan = orphan_1.Orphan;\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.PointerList = pointer_list_1.PointerList;\nvar pointer_type_1 = require(\"./pointer-type\");\nexports.PointerType = pointer_type_1.PointerType;\nvar pointer_1 = require(\"./pointer\");\nexports.Pointer = pointer_1.Pointer;\nvar struct_1 = require(\"./struct\");\nexports.Struct = struct_1.Struct;\nvar text_1 = require(\"./text\");\nexports.Text = text_1.Text;\nvar text_list_1 = require(\"./text-list\");\nexports.TextList = text_list_1.TextList;\nvar uint8_list_1 = require(\"./uint8-list\");\nexports.Uint8List = uint8_list_1.Uint8List;\nvar uint16_list_1 = require(\"./uint16-list\");\nexports.Uint16List = uint16_list_1.Uint16List;\nvar uint32_list_1 = require(\"./uint32-list\");\nexports.Uint32List = uint32_list_1.Uint32List;\nvar uint64_list_1 = require(\"./uint64-list\");\nexports.Uint64List = uint64_list_1.Uint64List;\nvar void_1 = require(\"./void\");\nexports.Void = void_1.Void;\nexports.VOID = void_1.VOID;\nvar void_list_1 = require(\"./void-list\");\nexports.VoidList = void_list_1.VoidList;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int16List, _super);\n    function Int16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt16(c.byteOffset + index * 2);\n    };\n    Int16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt16(c.byteOffset + index * 2, value);\n    };\n    Int16List.prototype.toString = function () {\n        return \"Int16_\" + _super.prototype.toString.call(this);\n    };\n    Int16List._capnp = {\n        displayName: 'List<Int16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Int16List;\n}(list_1.List));\nexports.Int16List = Int16List;\n\n//# sourceMappingURL=int16-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int32List, _super);\n    function Int32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt32(c.byteOffset + index * 4);\n    };\n    Int32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt32(c.byteOffset + index * 4, value);\n    };\n    Int32List.prototype.toString = function () {\n        return \"Int32_\" + _super.prototype.toString.call(this);\n    };\n    Int32List._capnp = {\n        displayName: 'List<Int32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Int32List;\n}(list_1.List));\nexports.Int32List = Int32List;\n\n//# sourceMappingURL=int32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64List, _super);\n    function Int64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt64(c.byteOffset + index * 8);\n    };\n    Int64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt64(c.byteOffset + index * 8, value);\n    };\n    Int64List.prototype.toString = function () {\n        return \"Int64_\" + _super.prototype.toString.call(this);\n    };\n    Int64List._capnp = {\n        displayName: 'List<Int64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Int64List;\n}(list_1.List));\nexports.Int64List = Int64List;\n\n//# sourceMappingURL=int64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Int8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Int8List, _super);\n    function Int8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getInt8(c.byteOffset + index);\n    };\n    Int8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setInt8(c.byteOffset + index, value);\n    };\n    Int8List.prototype.toString = function () {\n        return \"Int8_\" + _super.prototype.toString.call(this);\n    };\n    Int8List._capnp = {\n        displayName: 'List<Int8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Int8List;\n}(list_1.List));\nexports.Int8List = Int8List;\n\n//# sourceMappingURL=int8-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar interface_1 = require(\"./interface\");\nvar pointer_list_1 = require(\"./pointer-list\");\nexports.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);\n\n//# sourceMappingURL=interface-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar constants_1 = require(\"../../constants\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar pointer_1 = require(\"./pointer\");\nvar Interface = /** @class */ (function (_super) {\n    tslib_1.__extends(Interface, _super);\n    function Interface(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, 'new Interface'));\n        return _this;\n    }\n    return Interface;\n}(pointer_1.Pointer));\nexports.Interface = Interface;\n\n//# sourceMappingURL=interface.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list');\ntrace('load');\n/**\n * A generic list class. Implements Filterable,\n */\nvar List = /** @class */ (function (_super) {\n    tslib_1.__extends(List, _super);\n    function List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    List.toString = function () {\n        return this._capnp.displayName;\n    };\n    List.prototype.all = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            if (!callbackfn(this.get(i), i))\n                return false;\n        }\n        return true;\n    };\n    List.prototype.any = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            if (callbackfn(this.get(i), i))\n                return true;\n        return false;\n    };\n    List.prototype.ap = function (callbackfns) {\n        var _this = this;\n        var length = this.getLength();\n        var res = [];\n        var _loop_1 = function (i) {\n            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));\n        };\n        for (var i = 0; i < length; i++) {\n            _loop_1(i);\n        }\n        return res;\n    };\n    List.prototype.concat = function (other) {\n        var length = this.getLength();\n        var otherLength = other.getLength();\n        var res = new Array(length + otherLength);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        for (var i = 0; i < otherLength; i++)\n            res[i + length] = other.get(i);\n        return res;\n    };\n    List.prototype.drop = function (n) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = n; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.dropWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var drop = true;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            if (drop)\n                drop = callbackfn(v, i);\n            if (!drop)\n                res.push(v);\n        }\n        return res;\n    };\n    List.prototype.empty = function () { return []; };\n    List.prototype.every = function (callbackfn) { return this.all(callbackfn); };\n    List.prototype.filter = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                res.push(value);\n        }\n        return res;\n    };\n    List.prototype.find = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++) {\n            var value = this.get(i);\n            if (callbackfn(value, i))\n                return value;\n        }\n        return undefined;\n    };\n    List.prototype.forEach = function (callbackfn) {\n        var length = this.getLength();\n        for (var i = 0; i < length; i++)\n            callbackfn(this.get(i), i);\n    };\n    List.prototype.get = function (_index) {\n        throw new TypeError();\n    };\n    /**\n     * Get the length of this list.\n     *\n     * @returns {number} The number of elements in this list.\n     */\n    List.prototype.getLength = function () {\n        return pointer_1.getTargetListLength(this);\n    };\n    List.prototype.groupBy = function (callbackfn) {\n        var length = this.getLength();\n        var res = {};\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            res[callbackfn(v, i)] = v;\n        }\n        return res;\n    };\n    List.prototype.intersperse = function (sep) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++) {\n            if (i > 0)\n                res.push(sep);\n            res.push(this.get(i));\n        }\n        return res;\n    };\n    List.prototype.map = function (callbackfn) {\n        var length = this.getLength();\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = callbackfn(this.get(i), i);\n        return res;\n    };\n    List.prototype.reduce = function (callbackfn, initialValue) {\n        var i = 0;\n        var res;\n        if (initialValue === undefined) {\n            // LINT: It's okay, I know what I'm doing here.\n            /* tslint:disable-next-line:no-any */\n            res = this.get(0);\n            i++;\n        }\n        else {\n            res = initialValue;\n        }\n        for (; i < this.getLength(); i++)\n            res = callbackfn(res, this.get(i), i);\n        return res;\n    };\n    List.prototype.set = function (_index, _value) {\n        throw new TypeError();\n    };\n    List.prototype.slice = function (start, end) {\n        if (start === void 0) { start = 0; }\n        var length = end ? Math.min(this.getLength(), end) : this.getLength();\n        var res = new Array(length - start);\n        for (var i = start; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.some = function (callbackfn) { return this.any(callbackfn); };\n    List.prototype.take = function (n) {\n        var length = Math.min(this.getLength(), n);\n        var res = new Array(length);\n        for (var i = 0; i < length; i++)\n            res[i] = this.get(i);\n        return res;\n    };\n    List.prototype.takeWhile = function (callbackfn) {\n        var length = this.getLength();\n        var res = [];\n        var take;\n        for (var i = 0; i < length; i++) {\n            var v = this.get(i);\n            take = callbackfn(v, i);\n            if (!take)\n                return res;\n            res.push(v);\n        }\n        return res;\n    };\n    List.prototype.toArray = function () {\n        return this.map(util_1.identity);\n    };\n    List.prototype.toString = function () {\n        return \"List_\" + _super.prototype.toString.call(this);\n    };\n    List._capnp = {\n        displayName: 'List<Generic>',\n        size: list_element_size_1.ListElementSize.VOID,\n    };\n    List.initList = initList;\n    return List;\n}(pointer_1.Pointer));\nexports.List = List;\n/**\n * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in\n * the same segment as this pointer.\n *\n * @param {ListElementSize} elementSize The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {List<T>} l The list to initialize.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for\n * composite lists.\n * @returns {void}\n */\nfunction initList(elementSize, length, l, compositeSize) {\n    var c;\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            c = l.segment.allocate(Math.ceil(length / 8));\n            break;\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));\n            break;\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));\n            compositeSize = object_size_1.padToWord(compositeSize);\n            var byteLength = object_size_1.getByteLength(compositeSize) * length;\n            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance\n            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything\n            // starts off zeroed out so these nested structs don't need to be initialized in any way.\n            c = l.segment.allocate(byteLength + 8);\n            pointer_1.setStructPointer(length, compositeSize, c);\n            trace('Wrote composite tag word %s for %s.', c, l);\n            break;\n        case list_element_size_1.ListElementSize.VOID:\n            // No need to allocate anything, we can write the list pointer right here.\n            pointer_1.setListPointer(0, elementSize, length, l);\n            return;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);\n    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);\n}\nexports.initList = initList;\n\n//# sourceMappingURL=list.js.map\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar errors_1 = require(\"../../errors\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:orphan');\ntrace('load');\n// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to\n// make sure you don't accidentally adopt a pointer of the wrong type.\n/**\n * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left\n * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to\n * be reconstructed once another pointer is ready to adopt it.\n *\n * @export\n * @class Orphan\n * @extends {Pointer}\n * @template T\n */\nvar Orphan = /** @class */ (function () {\n    function Orphan(src) {\n        var c = pointer_1.getContent(src);\n        this.segment = c.segment;\n        this.byteOffset = c.byteOffset;\n        this._capnp = {};\n        // Read vital info from the src pointer so we can reconstruct it during adoption.\n        this._capnp.type = pointer_1.getTargetPointerType(src);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this._capnp.size = pointer_1.getTargetStructSize(src);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                this._capnp.length = pointer_1.getTargetListLength(src);\n                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                this._capnp.capId = pointer_1.getCapabilityId(src);\n                break;\n            default:\n                // COVERAGE: Unreachable code.\n                /* istanbul ignore next */\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        // Zero out the source pointer (but not the contents!).\n        pointer_1.erasePointer(src);\n    }\n    /**\n     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.\n     *\n     * @param {T} dst The destination pointer.\n     * @returns {void}\n     */\n    Orphan.prototype._moveTo = function (dst) {\n        if (this._capnp === undefined)\n            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));\n        // TODO: Implement copy semantics when this happens.\n        if (this.segment.message !== dst.segment.message)\n            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));\n        // Recursively wipe out the destination pointer first.\n        pointer_1.erase(dst);\n        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var offsetWords = res.offsetWords;\n                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE)\n                    offsetWords--; // The tag word gets skipped.\n                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);\n                break;\n            case pointer_type_1.PointerType.OTHER:\n                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);\n                break;\n            /* istanbul ignore next */\n            default:\n                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.dispose = function () {\n        // FIXME: Should this throw?\n        if (this._capnp === undefined) {\n            trace('not disposing an already disposed orphan', this);\n            return;\n        }\n        switch (this._capnp.type) {\n            case pointer_type_1.PointerType.STRUCT:\n                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));\n                break;\n            case pointer_type_1.PointerType.LIST:\n                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);\n                this.segment.fillZeroWords(this.byteOffset, byteLength);\n                break;\n            default:\n                // Other pointer types don't actually have any content.\n                break;\n        }\n        this._capnp = undefined;\n    };\n    Orphan.prototype.toString = function () {\n        return util_1.format('Orphan_%d@%a,type:%s', this.segment.id, this.byteOffset, this._capnp && this._capnp.type);\n    };\n    return Orphan;\n}());\nexports.Orphan = Orphan;\n\n//# sourceMappingURL=orphan.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar trace = debug_1.default('capnp:pointer-allocation-result');\ntrace('load');\n/**\n * This is used as the return value for `Pointer.prototype.initPointer`. Turns out using a class in V8 for multiple\n * return values is faster than using an array or anonymous object.\n *\n * http://jsben.ch/#/zTdbD\n *\n * @export\n * @class PointerAllocationResult\n */\nvar PointerAllocationResult = /** @class */ (function () {\n    function PointerAllocationResult(pointer, offsetWords) {\n        this.pointer = pointer;\n        this.offsetWords = offsetWords;\n    }\n    return PointerAllocationResult;\n}());\nexports.PointerAllocationResult = PointerAllocationResult;\n\n//# sourceMappingURL=pointer-allocation-result.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nfunction PointerList(PointerClass) {\n    return _a = /** @class */ (function (_super) {\n            tslib_1.__extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.get = function (index) {\n                var c = pointer_1.getContent(this);\n                return new PointerClass(c.segment, c.byteOffset + index * 8, this._capnp.depthLimit - 1);\n            };\n            class_1.prototype.set = function (index, value) {\n                pointer_1.copyFrom(value, this.get(index));\n            };\n            class_1.prototype.toString = function () {\n                return \"Pointer_\" + _super.prototype.toString.call(this) + \",cls:\" + PointerClass.toString();\n            };\n            return class_1;\n        }(list_1.List)),\n        _a._capnp = {\n            displayName: \"List<\" + PointerClass._capnp.displayName + \">\",\n            size: list_element_size_1.ListElementSize.POINTER,\n        },\n        _a;\n    var _a;\n}\nexports.PointerList = PointerList;\n\n//# sourceMappingURL=pointer-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PointerType;\n(function (PointerType) {\n    PointerType[PointerType[\"STRUCT\"] = 0] = \"STRUCT\";\n    PointerType[PointerType[\"LIST\"] = 1] = \"LIST\";\n    PointerType[PointerType[\"FAR\"] = 2] = \"FAR\";\n    PointerType[PointerType[\"OTHER\"] = 3] = \"OTHER\";\n})(PointerType = exports.PointerType || (exports.PointerType = {}));\n\n//# sourceMappingURL=pointer-type.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar orphan_1 = require(\"./orphan\");\nvar pointer_allocation_result_1 = require(\"./pointer-allocation-result\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:pointer');\ntrace('load');\n/**\n * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is\n * also sometimes used to reference an offset to a pointer's content or tag words.\n *\n * @export\n * @class Pointer\n */\nvar Pointer = /** @class */ (function () {\n    function Pointer(segment, byteOffset, depthLimit) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        if (depthLimit === 0)\n            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));\n        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).\n        trackPointerAllocation(segment.message, this);\n        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the\n        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language\n        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native\n        // code anyway.\n        if (byteOffset < 0 || byteOffset > segment.byteLength) {\n            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));\n        }\n        this._capnp = { compositeList: false, depthLimit: depthLimit };\n        this.segment = segment;\n        this.byteOffset = byteOffset;\n        trace('new %s', this);\n    }\n    Pointer.prototype.toString = function () {\n        return util_1.format('Pointer_%d@%a,%s,limit:%x', this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);\n    };\n    Pointer.adopt = adopt;\n    Pointer.copyFrom = copyFrom;\n    Pointer.disown = disown;\n    Pointer.dump = dump;\n    Pointer.isNull = isNull;\n    Pointer._capnp = {\n        displayName: 'Pointer',\n    };\n    return Pointer;\n}());\nexports.Pointer = Pointer;\n/**\n * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.\n *\n * @param {Orphan<Pointer>} src The orphan to adopt.\n * @param {Pointer} p The the pointer to adopt into.\n * @returns {void}\n */\nfunction adopt(src, p) {\n    src._moveTo(p);\n}\nexports.adopt = adopt;\n/**\n * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no\n * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.\n *\n * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan\n * object is then invalidated after adoption (can only adopt once!).\n *\n * @param {T} p The pointer to turn into an Orphan.\n * @returns {Orphan<T>} An orphaned pointer.\n */\nfunction disown(p) {\n    return new orphan_1.Orphan(p);\n}\nexports.disown = disown;\nfunction dump(p) {\n    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));\n}\nexports.dump = dump;\n/**\n * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the\n * nearest word.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @param {number} length The length of the list.\n * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if\n * `elementSize === ListElementSize.COMPOSITE`.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListByteLength(elementSize, length, compositeSize) {\n    switch (elementSize) {\n        case list_element_size_1.ListElementSize.BIT:\n            return util_1.padToWord(length + 7 >>> 3);\n        case list_element_size_1.ListElementSize.BYTE:\n        case list_element_size_1.ListElementSize.BYTE_2:\n        case list_element_size_1.ListElementSize.BYTE_4:\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n        case list_element_size_1.ListElementSize.VOID:\n            return util_1.padToWord(getListElementByteLength(elementSize) * length);\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            if (compositeSize === undefined)\n                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));\n            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));\n        /* istanbul ignore next */\n        default:\n            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);\n    }\n}\nexports.getListByteLength = getListByteLength;\n/**\n * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a\n * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.\n *\n * @param {ListElementSize} elementSize A number describing the size of the list elements.\n * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.\n */\nfunction getListElementByteLength(elementSize) {\n    switch (elementSize) {\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.BIT:\n            return NaN;\n        case list_element_size_1.ListElementSize.BYTE:\n            return 1;\n        case list_element_size_1.ListElementSize.BYTE_2:\n            return 2;\n        case list_element_size_1.ListElementSize.BYTE_4:\n            return 4;\n        case list_element_size_1.ListElementSize.BYTE_8:\n        case list_element_size_1.ListElementSize.POINTER:\n            return 8;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.COMPOSITE:\n            // Caller has to figure it out based on the tag word.\n            return NaN;\n        /* istanbul ignore next */\n        case list_element_size_1.ListElementSize.VOID:\n            return 0;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));\n    }\n}\nexports.getListElementByteLength = getListElementByteLength;\n/**\n * Add an offset to the pointer's offset and return a new Pointer for that address.\n *\n * @param {number} offset The number of bytes to add to the offset.\n * @param {Pointer} p The pointer to add from.\n * @returns {Pointer} A new pointer to the address.\n */\nfunction add(offset, p) {\n    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);\n}\nexports.add = add;\n/**\n * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.\n *\n * @param {Pointer} src The pointer to copy.\n * @param {Pointer} p The pointer to copy into.\n * @returns {void}\n */\nfunction copyFrom(src, p) {\n    // If the pointer is the same then this is a noop.\n    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {\n        trace('ignoring copy operation from identical pointer %s', src);\n        return;\n    }\n    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.\n    erase(p); // noop if null\n    if (isNull(src))\n        return;\n    switch (getTargetPointerType(src)) {\n        case pointer_type_1.PointerType.STRUCT:\n            copyFromStruct(src, p);\n            break;\n        case pointer_type_1.PointerType.LIST:\n            copyFromList(src, p);\n            break;\n        /* istanbul ignore next */\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n}\nexports.copyFrom = copyFrom;\n/**\n * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.\n *\n * Note that this will leave \"holes\" of zeroes in the message, since the space cannot be reclaimed. With packing this\n * will have a negligible effect on the final message size.\n *\n * FIXME: This may need protection against infinite recursion...\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erase(p) {\n    if (isNull(p))\n        return;\n    // First deal with the contents.\n    var c;\n    switch (getTargetPointerType(p)) {\n        case pointer_type_1.PointerType.STRUCT:\n            var size = getTargetStructSize(p);\n            c = getContent(p);\n            // Wipe the data section.\n            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);\n            // Iterate over all the pointers and nuke them.\n            for (var i = 0; i < size.pointerLength; i++) {\n                erase(add(i * 8, c));\n            }\n            break;\n        case pointer_type_1.PointerType.LIST:\n            var elementSize = getTargetListElementSize(p);\n            var length = getTargetListLength(p);\n            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));\n            c = getContent(p);\n            if (elementSize === list_element_size_1.ListElementSize.POINTER) {\n                for (var i = 0; i < length; i++) {\n                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));\n                }\n                // Calling erase on each pointer takes care of the content, nothing left to do here.\n                break;\n            }\n            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n                // Read some stuff from the tag word.\n                var tag = add(-8, c);\n                var compositeSize = getStructSize(tag);\n                var compositeByteLength = object_size_1.getByteLength(compositeSize);\n                contentWords = getOffsetWords(tag);\n                // Kill the tag word.\n                c.segment.setWordZero(c.byteOffset - 8);\n                // Recursively erase each pointer.\n                for (var i = 0; i < length; i++) {\n                    for (var j = 0; j < compositeSize.pointerLength; j++) {\n                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));\n                    }\n                }\n            }\n            c.segment.fillZeroWords(c.byteOffset, contentWords);\n            break;\n        case pointer_type_1.PointerType.OTHER:\n            // No content.\n            break;\n        default:\n            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));\n    }\n    erasePointer(p);\n}\nexports.erase = erase;\n/**\n * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.\n *\n * @param {Pointer} p The pointer to erase.\n * @returns {void}\n */\nfunction erasePointer(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p)) {\n            // Kill the double-far tag word.\n            landingPad.segment.setWordZero(landingPad.byteOffset + 8);\n        }\n        // Kill the landing pad.\n        landingPad.segment.setWordZero(landingPad.byteOffset);\n    }\n    // Finally! Kill the pointer itself...\n    p.segment.setWordZero(p.byteOffset);\n}\nexports.erasePointer = erasePointer;\n/**\n * Interpret the pointer as a far pointer, returning its target segment and offset.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the far target.\n */\nfunction followFar(p) {\n    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));\n    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;\n    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);\n}\nexports.followFar = followFar;\n/**\n * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.\n * Otherwise, returns the pointer unmodified.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.\n */\nfunction followFars(p) {\n    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {\n        var landingPad = followFar(p);\n        if (isDoubleFar(p))\n            landingPad.byteOffset += 8;\n        return landingPad;\n    }\n    return p;\n}\nexports.followFars = followFars;\nfunction getCapabilityId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getCapabilityId = getCapabilityId;\nfunction isCompositeList(p) {\n    return getTargetPointerType(p) === pointer_type_1.PointerType.LIST && getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE;\n}\n/**\n * Obtain the location of the pointer's content, following far pointers as needed.\n * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and\n * instead return a pointer to the parent list's contents (also the beginning of the first struct).\n * @returns {Pointer} A pointer to the beginning of the pointer's content.\n */\nfunction getContent(p, ignoreCompositeIndex) {\n    var c;\n    if (isDoubleFar(p)) {\n        var landingPad = followFar(p);\n        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);\n    }\n    else {\n        var target = followFars(p);\n        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);\n    }\n    if (isCompositeList(p))\n        c.byteOffset += 8;\n    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {\n        // Seek backwards by one word so we can read the struct size off the tag word.\n        c.byteOffset -= 8;\n        // Seek ahead by `compositeIndex` multiples of the struct's total size.\n        c.byteOffset += 8 + p._capnp.compositeIndex * object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));\n    }\n    return c;\n}\nexports.getContent = getContent;\n/**\n * Read the target segment ID from a far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The target segment ID.\n */\nfunction getFarSegmentId(p) {\n    return p.segment.getUint32(p.byteOffset + 4);\n}\nexports.getFarSegmentId = getFarSegmentId;\n/**\n * Get a number indicating the size of the list's elements.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the list's elements.\n */\nfunction getListElementSize(p) {\n    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n}\nexports.getListElementSize = getListElementSize;\n/**\n * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in\n * the list (not counting the tag word).\n *\n * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct\n * length for composite lists use `getTargetListLength()` instead.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The length of the list, or total number of words for composite lists.\n */\nfunction getListLength(p) {\n    return p.segment.getUint32(p.byteOffset + 4) >>> 3;\n}\nexports.getListLength = getListLength;\n/**\n * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the\n * beginning of the data section, and for list pointers it is the location of the first element. The value should\n * always be zero for interface pointers.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.\n */\nfunction getOffsetWords(p) {\n    var o = p.segment.getInt32(p.byteOffset);\n    // Far pointers only have 29 offset bits.\n    return o & 2 ? o >> 3 : o >> 2;\n}\nexports.getOffsetWords = getOffsetWords;\n/**\n * Look up the pointer's type.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer.\n */\nfunction getPointerType(p) {\n    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;\n}\nexports.getPointerType = getPointerType;\n/**\n * Read the number of data words from this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of data words in the struct.\n */\nfunction getStructDataWords(p) {\n    return p.segment.getUint16(p.byteOffset + 4);\n}\nexports.getStructDataWords = getStructDataWords;\n/**\n * Read the number of pointers contained in this struct pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of pointers in this struct.\n */\nfunction getStructPointerLength(p) {\n    return p.segment.getUint16(p.byteOffset + 6);\n}\nexports.getStructPointerLength = getStructPointerLength;\n/**\n * Get an object describing this struct pointer's size.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} The size of the struct.\n */\nfunction getStructSize(p) {\n    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));\n}\nexports.getStructSize = getStructSize;\n/**\n * Get a pointer to this pointer's composite list tag word, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {Pointer} A pointer to the list's composite tag word.\n */\nfunction getTargetCompositeListTag(p) {\n    var c = getContent(p);\n    // The composite list tag is always one word before the content.\n    c.byteOffset -= 8;\n    return c;\n}\nexports.getTargetCompositeListTag = getTargetCompositeListTag;\n/**\n * Get the object size for the target composite list, following far pointers as needed.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ObjectSize} An object describing the size of each struct in the list.\n */\nfunction getTargetCompositeListSize(p) {\n    return getStructSize(getTargetCompositeListTag(p));\n}\nexports.getTargetCompositeListSize = getTargetCompositeListSize;\n/**\n * Get the size of the list elements referenced by this pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {ListElementSize} The size of the elements in the list.\n */\nfunction getTargetListElementSize(p) {\n    return getListElementSize(followFars(p));\n}\nexports.getTargetListElementSize = getTargetListElementSize;\n/**\n * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a\n * composite list, it will look up the tag word and read the length from there.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {number} The number of elements in the list.\n */\nfunction getTargetListLength(p) {\n    var t = followFars(p);\n    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {\n        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.\n        return getOffsetWords(getTargetCompositeListTag(p));\n    }\n    return getListLength(t);\n}\nexports.getTargetListLength = getTargetListLength;\n/**\n * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling\n * `getPointerType()`.\n *\n * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is\n * encountered.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {PointerType} The type of pointer referenced by this pointer.\n */\nfunction getTargetPointerType(p) {\n    var t = getPointerType(followFars(p));\n    if (t === pointer_type_1.PointerType.FAR)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));\n    return t;\n}\nexports.getTargetPointerType = getTargetPointerType;\n/**\n * Get the size of the struct referenced by a pointer, following far pointers if necessary.\n *\n * @param {Pointer} p The poiner to read from.\n * @returns {ObjectSize} The size of the struct referenced by this pointer.\n */\nfunction getTargetStructSize(p) {\n    return getStructSize(followFars(p));\n}\nexports.getTargetStructSize = getTargetStructSize;\n/**\n * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the\n * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.\n *\n * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset\n * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.\n *\n * @param {Segment} contentSegment The segment containing this pointer's content.\n * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.\n * @param {Pointer} p The pointer to initialize.\n * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and\n * the value to use as the offset for that pointer.\n */\nfunction initPointer(contentSegment, contentOffset, p) {\n    if (p.segment !== contentSegment) {\n        // Need a far pointer.\n        trace('Initializing far pointer %s -> %s.', p, contentSegment);\n        if (!contentSegment.hasCapacity(8)) {\n            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.\n            var landingPad_1 = p.segment.allocate(16);\n            trace('GAH! Initializing double-far pointer in %s from %s -> %s.', p, contentSegment, landingPad_1);\n            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);\n            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);\n            landingPad_1.byteOffset += 8;\n            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);\n        }\n        // Allocate a far pointer landing pad in the target segment.\n        var landingPad = contentSegment.allocate(8);\n        if (landingPad.segment.id !== contentSegment.id) {\n            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n        }\n        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);\n        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);\n    }\n    trace('Initializing intra-segment pointer %s -> %a.', p, contentOffset);\n    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);\n}\nexports.initPointer = initPointer;\n/**\n * Check if the pointer is a double-far pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.\n */\nfunction isDoubleFar(p) {\n    return getPointerType(p) === pointer_type_1.PointerType.FAR && (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0;\n}\nexports.isDoubleFar = isDoubleFar;\n/**\n * Quickly check to see if the pointer is \"null\". A \"null\" pointer is a zero word, equivalent to an empty struct\n * pointer.\n *\n * @param {Pointer} p The pointer to read from.\n * @returns {boolean} `true` if the pointer is \"null\".\n */\nfunction isNull(p) {\n    return p.segment.isWordZero(p.byteOffset);\n}\nexports.isNull = isNull;\n/**\n * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far\n * pointers as needed if the content is in a different segment than the destination. After the relocation the source\n * pointer will be erased and is no longer valid.\n *\n * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before\n * relocating!\n * @param {Pointer} src The pointer to relocate.\n * @returns {void}\n */\nfunction relocateTo(dst, src) {\n    var t = followFars(src);\n    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset\n    var hi = t.segment.getUint32(t.byteOffset + 4);\n    // Make sure anything dst was pointing to is wiped out.\n    erase(dst);\n    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);\n    // Keep the low 2 bits and write the new offset.\n    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));\n    // Keep the high 32 bits intact.\n    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);\n    erasePointer(src);\n}\nexports.relocateTo = relocateTo;\n/**\n * Write a far pointer.\n *\n * @param {boolean} doubleFar Set to `true` if this is a double far pointer.\n * @param {number} offsetWords The offset, in words, to the target pointer.\n * @param {number} segmentId The segment the target pointer is located in.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setFarPointer(doubleFar, offsetWords, segmentId, p) {\n    var A = pointer_type_1.PointerType.FAR;\n    var B = doubleFar ? 1 : 0;\n    var C = offsetWords;\n    var D = segmentId;\n    p.segment.setUint32(p.byteOffset, A | B << 2 | C << 3);\n    p.segment.setUint32(p.byteOffset + 4, D);\n}\nexports.setFarPointer = setFarPointer;\n/**\n * Write a raw interface pointer.\n *\n * @param {number} capId The capability ID.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setInterfacePointer(capId, p) {\n    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);\n    p.segment.setUint32(p.byteOffset + 4, capId);\n}\nexports.setInterfacePointer = setInterfacePointer;\n/**\n * Write a raw list pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.\n * @param {ListElementSize} size The size of each element in the list.\n * @param {number} length The number of elements in the list.\n * @param {Pointer} p The pointer to write to.\n * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This\n * is required for composite lists.\n * @returns {void}\n */\nfunction setListPointer(offsetWords, size, length, p, compositeSize) {\n    if (p === undefined)\n        throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);\n    var A = pointer_type_1.PointerType.LIST;\n    var B = offsetWords;\n    var C = size;\n    var D = length;\n    if (size === list_element_size_1.ListElementSize.COMPOSITE) {\n        if (compositeSize === undefined)\n            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);\n        D *= object_size_1.getWordLength(compositeSize);\n    }\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint32(p.byteOffset + 4, C | D << 3);\n}\nexports.setListPointer = setListPointer;\n/**\n * Write a raw struct pointer.\n *\n * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data\n * section.\n * @param {ObjectSize} size An object describing the size of the struct.\n * @param {Pointer} p The pointer to write to.\n * @returns {void}\n */\nfunction setStructPointer(offsetWords, size, p) {\n    var A = pointer_type_1.PointerType.STRUCT;\n    var B = offsetWords;\n    var C = object_size_1.getDataWordLength(size);\n    var D = size.pointerLength;\n    p.segment.setUint32(p.byteOffset, A | B << 2);\n    p.segment.setUint16(p.byteOffset + 4, C);\n    p.segment.setUint16(p.byteOffset + 6, D);\n}\nexports.setStructPointer = setStructPointer;\n/**\n * Read some bits off a pointer to make sure it has the right pointer data.\n *\n * @param {PointerType} pointerType The expected pointer type.\n * @param {Pointer} p The pointer to validate.\n * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this\n * undefined for struct pointers.\n * @returns {void}\n */\nfunction validate(pointerType, p, elementSize) {\n    if (isNull(p))\n        return;\n    var t = followFars(p);\n    // Check the pointer type.\n    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;\n    if (A !== pointerType)\n        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));\n    // Check the list element size, if provided.\n    if (elementSize !== undefined) {\n        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;\n        if (C !== elementSize)\n            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));\n    }\n}\nexports.validate = validate;\nfunction copyFromList(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcElementSize = getTargetListElementSize(src);\n    var srcLength = getTargetListLength(src);\n    var srcCompositeSize;\n    var srcStructByteLength;\n    var dstContent;\n    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(getTargetCompositeListSize(src)) * srcLength);\n        // Recursively copy each pointer in the list.\n        for (var i = 0; i < srcLength; i++) {\n            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);\n            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);\n            copyFrom(srcPtr, dstPtr);\n        }\n    }\n    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {\n        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));\n        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);\n        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);\n        // Copy the tag word.\n        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);\n        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`\n        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.\n        // PERF: Skip this step if the composite struct only contains pointers.\n        if (srcCompositeSize.dataByteLength > 0) {\n            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;\n            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);\n        }\n        // Recursively copy all the pointers in each struct.\n        for (var i = 0; i < srcLength; i++) {\n            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {\n                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);\n                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);\n                copyFrom(srcPtr, dstPtr);\n            }\n        }\n    }\n    else {\n        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT\n            ? srcLength + 7 >>> 3\n            : getListElementByteLength(srcElementSize) * srcLength);\n        var wordLength = byteLength >>> 3;\n        dstContent = dst.segment.allocate(byteLength);\n        // Copy all of the list contents word-by-word.\n        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);\n    }\n    // Initialize the list pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);\n}\nexports.copyFromList = copyFromList;\nfunction copyFromStruct(src, dst) {\n    if (dst._capnp.depthLimit <= 0)\n        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);\n    var srcContent = getContent(src);\n    var srcSize = getTargetStructSize(src);\n    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);\n    // Allocate space for the destination content.\n    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));\n    // Copy the data section.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);\n    // Copy the pointer section.\n    for (var i = 0; i < srcSize.pointerLength; i++) {\n        var offset = srcSize.dataByteLength + i * 8;\n        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);\n        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);\n        copyFrom(srcPtr, dstPtr);\n    }\n    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's\n    // no pointer to copy here and we've already copied the contents.\n    if (dst._capnp.compositeList)\n        return;\n    // Initialize the struct pointer.\n    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);\n    setStructPointer(res.offsetWords, srcSize, res.pointer);\n}\nexports.copyFromStruct = copyFromStruct;\n/**\n * Track the allocation of a new Pointer object.\n *\n * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After\n * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.\n *\n * @param {Message} message The message the pointer belongs to.\n * @param {Pointer} p The pointer being allocated.\n * @returns {void}\n */\nfunction trackPointerAllocation(message, p) {\n    message._capnp.traversalLimit -= 8;\n    if (message._capnp.traversalLimit <= 0) {\n        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));\n    }\n}\nexports.trackPointerAllocation = trackPointerAllocation;\n\n//# sourceMappingURL=pointer.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../../constants\");\nvar types_1 = require(\"../../types\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar object_size_1 = require(\"../object-size\");\nvar data_1 = require(\"./data\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar text_1 = require(\"./text\");\nvar errors_1 = require(\"../../errors\");\nvar trace = debug_1.default('capnp:struct');\ntrace('load');\n// Used to apply bit masks (default values).\nvar TMP_WORD = new DataView(new ArrayBuffer(8));\nvar Struct = /** @class */ (function (_super) {\n    tslib_1.__extends(Struct, _super);\n    /**\n     * Create a new pointer to a struct.\n     *\n     * @constructor {Struct}\n     * @param {Segment} segment The segment the pointer resides in.\n     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.\n     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.\n     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list\n     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within\n     * the list. It is not valid to call `initStruct()` on a composite struct – the struct contents are initialized when\n     * the list pointer is initialized.\n     */\n    function Struct(segment, byteOffset, depthLimit, compositeIndex) {\n        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }\n        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;\n        _this._capnp.compositeIndex = compositeIndex;\n        _this._capnp.compositeList = compositeIndex !== undefined;\n        return _this;\n    }\n    Struct.toString = function () {\n        return this._capnp.displayName;\n    };\n    Struct.prototype.toString = function () {\n        return \"Struct_\" + _super.prototype.toString.call(this) +\n            (\"\" + (this._capnp.compositeIndex === undefined ? '' : \",ci:\" + this._capnp.compositeIndex));\n    };\n    Struct._capnp = {\n        displayName: 'Struct',\n    };\n    Struct.getAs = getAs;\n    Struct.getBit = getBit;\n    Struct.getData = getData;\n    Struct.getFloat32 = getFloat32;\n    Struct.getFloat64 = getFloat64;\n    Struct.getUint8 = getUint8;\n    Struct.getUint16 = getUint16;\n    Struct.getUint32 = getUint32;\n    Struct.getUint64 = getUint64;\n    Struct.getInt8 = getInt8;\n    Struct.getInt16 = getInt16;\n    Struct.getInt32 = getInt32;\n    Struct.getInt64 = getInt64;\n    Struct.getList = getList;\n    Struct.getPointer = getPointer;\n    Struct.getPointerAs = getPointerAs;\n    Struct.getStruct = getStruct;\n    Struct.getText = getText;\n    Struct.initData = initData;\n    Struct.initList = initList;\n    Struct.initStruct = initStruct;\n    Struct.initStructAt = initStructAt;\n    Struct.setBit = setBit;\n    Struct.setFloat32 = setFloat32;\n    Struct.setFloat64 = setFloat64;\n    Struct.setUint8 = setUint8;\n    Struct.setUint16 = setUint16;\n    Struct.setUint32 = setUint32;\n    Struct.setUint64 = setUint64;\n    Struct.setInt8 = setInt8;\n    Struct.setInt16 = setInt16;\n    Struct.setInt32 = setInt32;\n    Struct.setInt64 = setInt64;\n    Struct.setText = setText;\n    Struct.testWhich = testWhich;\n    return Struct;\n}(pointer_1.Pointer));\nexports.Struct = Struct;\n/**\n * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in\n * the same segment as this pointer.\n *\n * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.\n * @param {Struct} s The struct to initialize.\n * @returns {void}\n */\nfunction initStruct(size, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));\n    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).\n    pointer_1.erase(s);\n    var c = s.segment.allocate(object_size_1.getByteLength(size));\n    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);\n}\nexports.initStruct = initStruct;\nfunction initStructAt(index, StructClass, p) {\n    var s = getPointerAs(index, StructClass, p);\n    initStruct(StructClass._capnp.size, s);\n    return s;\n}\nexports.initStructAt = initStructAt;\n/**\n * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer\n * sections will be resized to the provided size.\n *\n * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!\n *\n * @param {ObjectSize} dstSize The desired size for the struct contents.\n * @param {Struct} s The struct to resize.\n * @returns {void}\n */\nfunction resize(dstSize, s) {\n    var srcSize = getSize(s);\n    var srcContent = pointer_1.getContent(s);\n    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));\n    // Only copy the data section for now. The pointer section will need to be rewritten.\n    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));\n    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);\n    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);\n    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit\n    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and\n    // the new pointers might need to be allocated as far pointers if the segment is full.\n    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {\n        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);\n        var srcPtrTarget = pointer_1.followFars(srcPtr);\n        var srcPtrContent = pointer_1.getContent(srcPtr);\n        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);\n        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent\n        // returns.\n        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n            srcPtrContent.byteOffset -= 8;\n        }\n        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n        // Read the old pointer data, but discard the original offset.\n        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n    }\n    // Zero out the old data and pointer sections.\n    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));\n}\nexports.resize = resize;\nfunction adopt(src, s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));\n    pointer_1.Pointer.adopt(src, s);\n}\nexports.adopt = adopt;\nfunction disown(s) {\n    if (s._capnp.compositeIndex !== undefined)\n        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));\n    return pointer_1.Pointer.disown(s);\n}\nexports.disown = disown;\n/**\n * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.\n *\n * @protected\n * @template T\n * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.\n * @param {Struct} s The struct to convert.\n * @returns {T} A new instance of the desired struct class pointing to the same location.\n */\nfunction getAs(StructClass, s) {\n    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);\n}\nexports.getAs = getAs;\n/**\n * Read a boolean (bit) value out of a struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {boolean} The value.\n */\nfunction getBit(bitOffset, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    if (defaultMask === undefined)\n        return (v & bitMask) !== 0;\n    var defaultValue = defaultMask.getUint8(0);\n    return ((v ^ defaultValue) & bitMask) !== 0;\n}\nexports.getBit = getBit;\nfunction getData(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);\n    }\n    return l;\n}\nexports.getData = getData;\nfunction getDataSection(s) {\n    return pointer_1.getContent(s);\n}\nexports.getDataSection = getDataSection;\n/**\n * Read a float32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getFloat32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getFloat32 = getFloat32;\n/**\n * Read a float64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getFloat64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);\n    }\n    return ds.segment.getFloat64(ds.byteOffset + byteOffset);\n}\nexports.getFloat64 = getFloat64;\n/**\n * Read an int16 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt16(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt16 = getInt16;\n/**\n * Read an int32 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt32(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);\n    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);\n}\nexports.getInt32 = getInt32;\n/**\n * Read an int64 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getInt64 = getInt64;\n/**\n * Read an int8 value out of this segment.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getInt8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getInt8(ds.byteOffset + byteOffset);\n    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n    TMP_WORD.setUint8(0, v);\n    return TMP_WORD.getInt8(0);\n}\nexports.getInt8 = getInt8;\nfunction getList(index, ListClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    if (pointer_1.isNull(l)) {\n        list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);\n    }\n    else if (ListClass._capnp.compositeSize !== undefined) {\n        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as\n        // specified in the schema. If the new schema has added fields we'll need to \"resize\" (shallow-copy) the list so\n        // it has room for the new fields.\n        var srcSize = pointer_1.getTargetCompositeListSize(l);\n        var dstSize = ListClass._capnp.compositeSize;\n        if (dstSize.dataByteLength > srcSize.dataByteLength || dstSize.pointerLength > srcSize.pointerLength) {\n            var srcContent = pointer_1.getContent(l);\n            var srcLength = pointer_1.getTargetListLength(l);\n            trace('resizing composite list %s due to protocol upgrade, new size: %d', l, object_size_1.getByteLength(dstSize) * srcLength);\n            // Allocate an extra 8 bytes for the tag.\n            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);\n            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);\n            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);\n            // Write the new tag word.\n            pointer_1.setStructPointer(srcLength, dstSize, dstContent);\n            // Seek ahead past the tag word before copying the content.\n            dstContent.byteOffset += 8;\n            for (var i = 0; i < srcLength; i++) {\n                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);\n                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);\n                // Copy the data section.\n                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));\n                // Iterate through the pointers and update the offsets so they point to the right place.\n                for (var j = 0; j < srcSize.pointerLength; j++) {\n                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);\n                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);\n                    var srcPtrTarget = pointer_1.followFars(srcPtr);\n                    var srcPtrContent = pointer_1.getContent(srcPtr);\n                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&\n                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {\n                        srcPtrContent.byteOffset -= 8;\n                    }\n                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);\n                    // Read the old pointer data, but discard the original offset.\n                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;\n                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);\n                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));\n                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);\n                }\n            }\n            // Zero out the old content.\n            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);\n        }\n    }\n    return l;\n}\nexports.getList = getList;\nfunction getPointer(index, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointer = getPointer;\nfunction getPointerAs(index, PointerClass, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n}\nexports.getPointerAs = getPointerAs;\nfunction getPointerSection(s) {\n    var ps = pointer_1.getContent(s);\n    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);\n    return ps;\n}\nexports.getPointerSection = getPointerSection;\nfunction getSize(s) {\n    if (s._capnp.compositeIndex !== undefined) {\n        // For composite lists the object size is stored in a tag word right before the content.\n        var c = pointer_1.getContent(s, true);\n        c.byteOffset -= 8;\n        return pointer_1.getStructSize(c);\n    }\n    return pointer_1.getTargetStructSize(s);\n}\nexports.getSize = getSize;\nfunction getStruct(index, StructClass, s) {\n    var t = getPointerAs(index, StructClass, s);\n    if (pointer_1.isNull(t)) {\n        initStruct(StructClass._capnp.size, t);\n    }\n    else {\n        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);\n        var ts = pointer_1.getTargetStructSize(t);\n        // This can happen when reading a struct that was constructed with an older version of the same schema, and new\n        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the\n        // data and pointer sections. This will unfortunately leave a \"hole\" of zeroes in the message, but that hole will\n        // at least compress well.\n        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength\n            || ts.pointerLength < StructClass._capnp.size.pointerLength) {\n            trace('need to resize child struct %s', t);\n            resize(StructClass._capnp.size, t);\n        }\n    }\n    return t;\n}\nexports.getStruct = getStruct;\nfunction getText(index, s) {\n    return text_1.Text.fromPointer(getPointer(index, s)).get(0);\n}\nexports.getText = getText;\n/**\n * Read an uint16 value out of a struct..\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint16(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint16(ds.byteOffset + byteOffset);\n    return ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);\n}\nexports.getUint16 = getUint16;\n/**\n * Read an uint32 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint32(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint32(ds.byteOffset + byteOffset);\n    return ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n}\nexports.getUint32 = getUint32;\n/**\n * Read an uint64 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint64(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint64(ds.byteOffset + byteOffset);\n    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);\n    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^ defaultMask.getUint32(4, true);\n    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);\n    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);\n    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));\n}\nexports.getUint64 = getUint64;\n/**\n * Read an uint8 value out of a struct.\n *\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {Struct} s The struct to read from.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {number} The value.\n */\nfunction getUint8(byteOffset, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask === undefined)\n        return ds.segment.getUint8(ds.byteOffset + byteOffset);\n    return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);\n}\nexports.getUint8 = getUint8;\nfunction initData(index, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);\n    return l;\n}\nexports.initData = initData;\nfunction initList(index, ListClass, length, s) {\n    checkPointerBounds(index, s);\n    var ps = getPointerSection(s);\n    ps.byteOffset += index * 8;\n    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);\n    pointer_1.erase(l);\n    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);\n    return l;\n}\nexports.initList = initList;\n/**\n * Write a boolean (bit) value to the struct.\n *\n * @protected\n * @param {number} bitOffset The offset in **bits** from the start of the data section.\n * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setBit(bitOffset, value, s, defaultMask) {\n    var byteOffset = Math.floor(bitOffset / 8);\n    var bitMask = 1 << bitOffset % 8;\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);\n    // If the default mask bit is set, that means `true` values are actually written as `0`.\n    if (defaultMask !== undefined)\n        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);\n}\nexports.setBit = setBit;\n/**\n * Write a primitive float32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat32 = setFloat32;\n/**\n * Write a primitive float64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setFloat64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(4, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);\n        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);\n        return;\n    }\n    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);\n}\nexports.setFloat64 = setFloat64;\n/**\n * Write a primitive int16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint16(0, true);\n        ds.segment.setUint16(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt16(ds.byteOffset + byteOffset, value);\n}\nexports.setInt16 = setInt16;\n/**\n * Write a primitive int32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);\n        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^ defaultMask.getUint32(0, true);\n        ds.segment.setUint32(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt32(ds.byteOffset + byteOffset, value);\n}\nexports.setInt32 = setInt32;\n/**\n * Write a primitive int64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setInt64(ds.byteOffset + byteOffset, value);\n}\nexports.setInt64 = setInt64;\n/**\n * Write a primitive int8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setInt8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        TMP_WORD.setInt8(0, value);\n        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);\n        ds.segment.setUint8(ds.byteOffset + byteOffset, v);\n        return;\n    }\n    ds.segment.setInt8(ds.byteOffset + byteOffset, value);\n}\nexports.setInt8 = setInt8;\nfunction setPointer(index, value, s) {\n    pointer_1.copyFrom(value, getPointer(index, s));\n}\nexports.setPointer = setPointer;\nfunction setText(index, value, s) {\n    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);\n}\nexports.setText = setText;\n/**\n * Write a primitive uint16 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint16(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 2, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint16(0, true);\n    ds.segment.setUint16(ds.byteOffset + byteOffset, value);\n}\nexports.setUint16 = setUint16;\n/**\n * Write a primitive uint32 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint32(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 4, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint32(0, true);\n    ds.segment.setUint32(ds.byteOffset + byteOffset, value);\n}\nexports.setUint32 = setUint32;\n/**\n * Write a primitive uint64 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint64(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 8, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined) {\n        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a\n        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in\n        // little-endian format by design.\n        for (var i = 0; i < 8; i++) {\n            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));\n        }\n        return;\n    }\n    ds.segment.setUint64(ds.byteOffset + byteOffset, value);\n}\nexports.setUint64 = setUint64;\n/**\n * Write a primitive uint8 value to the struct.\n *\n * @protected\n * @param {number} byteOffset The offset in bytes from the start of the data section.\n * @param {number} value The value to write.\n * @param {Struct} s The struct to write to.\n * @param {DataView} [defaultMask] The default value as a DataView.\n * @returns {void}\n */\nfunction setUint8(byteOffset, value, s, defaultMask) {\n    checkDataBounds(byteOffset, 1, s);\n    var ds = getDataSection(s);\n    if (defaultMask !== undefined)\n        value ^= defaultMask.getUint8(0);\n    ds.segment.setUint8(ds.byteOffset + byteOffset, value);\n}\nexports.setUint8 = setUint8;\nfunction testWhich(name, found, wanted, s) {\n    if (found !== wanted)\n        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));\n}\nexports.testWhich = testWhich;\nfunction checkDataBounds(byteOffset, byteLength, s) {\n    var dataByteLength = getSize(s).dataByteLength;\n    if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));\n    }\n}\nexports.checkDataBounds = checkDataBounds;\nfunction checkPointerBounds(index, s) {\n    var pointerLength = getSize(s).pointerLength;\n    if (index < 0 || index >= pointerLength) {\n        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));\n    }\n}\nexports.checkPointerBounds = checkPointerBounds;\n\n//# sourceMappingURL=struct.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar text_1 = require(\"./text\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar TextList = /** @class */ (function (_super) {\n    tslib_1.__extends(TextList, _super);\n    function TextList() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TextList.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        return text_1.Text.fromPointer(c).get(0);\n    };\n    TextList.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.byteOffset += index * 8;\n        text_1.Text.fromPointer(c).set(0, value);\n    };\n    TextList.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    TextList._capnp = {\n        displayName: 'List<Text>',\n        size: list_element_size_1.ListElementSize.POINTER,\n    };\n    return TextList;\n}(list_1.List));\nexports.TextList = TextList;\n\n//# sourceMappingURL=text-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar util_1 = require(\"../../util\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar pointer_type_1 = require(\"./pointer-type\");\nvar trace = debug_1.default('capnp:text');\ntrace('load');\nvar Text = /** @class */ (function (_super) {\n    tslib_1.__extends(Text, _super);\n    function Text() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Text.fromPointer = function (pointer) {\n        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);\n        return textFromPointerUnchecked(pointer);\n    };\n    /**\n     * Read a utf-8 encoded string value from this pointer.\n     *\n     * @param {number} [index] The index at which to start reading; defaults to zero.\n     * @returns {string} The string value.\n     */\n    Text.prototype.get = function (index) {\n        if (index === void 0) { index = 0; }\n        if (index !== 0)\n            trace('Called get() on %s with a strange index (%d).', this, index);\n        if (pointer_1.isNull(this))\n            return '';\n        var c = pointer_1.getContent(this);\n        // Remember to exclude the NUL byte.\n        return util_1.decodeUtf8(new Uint8Array(c.segment.buffer, c.byteOffset + index, this.getLength() - index));\n    };\n    /**\n     * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.\n     *\n     * @returns {number} The number of bytes allocated for the text.\n     */\n    Text.prototype.getLength = function () {\n        return _super.prototype.getLength.call(this) - 1;\n    };\n    /**\n     * Write a utf-8 encoded string value starting at the specified index.\n     *\n     * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes\n     * before `index` will be left as-is. All bytes after `index` will be overwritten.\n     * @param {string} value The string value to set.\n     * @returns {void}\n     */\n    Text.prototype.set = function (index, value) {\n        if (index !== 0)\n            trace('Called set() on %s with a strange index (%d).', this, index);\n        var src = util_1.encodeUtf8(value);\n        var dstLength = src.byteLength + index;\n        var c;\n        var original;\n        // TODO: Consider reusing existing space if list is already initialized and there's enough room for the value.\n        if (!pointer_1.isNull(this)) {\n            c = pointer_1.getContent(this);\n            // Only copy bytes that will remain after copying. Everything after `index` should end up truncated.\n            var originalLength = this.getLength();\n            if (originalLength >= index) {\n                originalLength = index;\n            }\n            else {\n                trace('%d byte gap exists between original text and new text in %s.', index - originalLength, this);\n            }\n            original = new Uint8Array(c.segment.buffer.slice(c.byteOffset, c.byteOffset + Math.min(originalLength, index)));\n            pointer_1.erase(this);\n        }\n        // Always allocate an extra byte for the NUL byte.\n        list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);\n        c = pointer_1.getContent(this);\n        var dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);\n        if (original)\n            dst.set(original);\n        dst.set(src, index);\n    };\n    Text.prototype.toString = function () {\n        return \"Text_\" + _super.prototype.toString.call(this);\n    };\n    return Text;\n}(list_1.List));\nexports.Text = Text;\nfunction textFromPointerUnchecked(pointer) {\n    return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);\n}\n\n//# sourceMappingURL=text.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint16List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint16List, _super);\n    function Uint16List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint16List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint16(c.byteOffset + index * 2);\n    };\n    Uint16List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint16(c.byteOffset + index * 2, value);\n    };\n    Uint16List.prototype.toString = function () {\n        return \"Uint16_\" + _super.prototype.toString.call(this);\n    };\n    Uint16List._capnp = {\n        displayName: 'List<Uint16>',\n        size: list_element_size_1.ListElementSize.BYTE_2,\n    };\n    return Uint16List;\n}(list_1.List));\nexports.Uint16List = Uint16List;\n\n//# sourceMappingURL=uint16-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint32List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint32List, _super);\n    function Uint32List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint32List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint32(c.byteOffset + index * 4);\n    };\n    Uint32List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint32(c.byteOffset + index * 4, value);\n    };\n    Uint32List.prototype.toString = function () {\n        return \"Uint32_\" + _super.prototype.toString.call(this);\n    };\n    Uint32List._capnp = {\n        displayName: 'List<Uint32>',\n        size: list_element_size_1.ListElementSize.BYTE_4,\n    };\n    return Uint32List;\n}(list_1.List));\nexports.Uint32List = Uint32List;\n\n//# sourceMappingURL=uint32-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint64List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint64List, _super);\n    function Uint64List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint64List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint64(c.byteOffset + index * 8);\n    };\n    Uint64List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint64(c.byteOffset + index * 8, value);\n    };\n    Uint64List.prototype.toString = function () {\n        return \"Uint64_\" + _super.prototype.toString.call(this);\n    };\n    Uint64List._capnp = {\n        displayName: 'List<Uint64>',\n        size: list_element_size_1.ListElementSize.BYTE_8,\n    };\n    return Uint64List;\n}(list_1.List));\nexports.Uint64List = Uint64List;\n\n//# sourceMappingURL=uint64-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar list_element_size_1 = require(\"../list-element-size\");\nvar list_1 = require(\"./list\");\nvar pointer_1 = require(\"./pointer\");\nvar trace = debug_1.default('capnp:list:composite');\ntrace('load');\nvar Uint8List = /** @class */ (function (_super) {\n    tslib_1.__extends(Uint8List, _super);\n    function Uint8List() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Uint8List.prototype.get = function (index) {\n        var c = pointer_1.getContent(this);\n        return c.segment.getUint8(c.byteOffset + index);\n    };\n    Uint8List.prototype.set = function (index, value) {\n        var c = pointer_1.getContent(this);\n        c.segment.setUint8(c.byteOffset + index, value);\n    };\n    Uint8List.prototype.toString = function () {\n        return \"Uint8_\" + _super.prototype.toString.call(this);\n    };\n    Uint8List._capnp = {\n        displayName: 'List<Uint8>',\n        size: list_element_size_1.ListElementSize.BYTE,\n    };\n    return Uint8List;\n}(list_1.List));\nexports.Uint8List = Uint8List;\n\n//# sourceMappingURL=uint8-list.js.map\n","\"use strict\";\n/**\n * Why would anyone **SANE** ever use this!?\n *\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pointer_list_1 = require(\"./pointer-list\");\nvar void_1 = require(\"./void\");\nexports.VoidList = pointer_list_1.PointerList(void_1.Void);\n\n//# sourceMappingURL=void-list.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar object_size_1 = require(\"../object-size\");\nvar struct_1 = require(\"./struct\");\nvar Void = /** @class */ (function (_super) {\n    tslib_1.__extends(Void, _super);\n    function Void() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Void._capnp = {\n        displayName: 'Void',\n        id: '0',\n        size: new object_size_1.ObjectSize(0, 0),\n    };\n    return Void;\n}(struct_1.Struct));\nexports.Void = Void;\n// This following line makes a mysterious \"whooshing\" sound when it runs.\nexports.VOID = undefined;\n\n//# sourceMappingURL=void.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar types_1 = require(\"../types\");\nvar util_1 = require(\"../util\");\nvar pointers_1 = require(\"./pointers\");\nvar trace = debug_1.default('capnp:segment');\ntrace('load');\nvar Segment = /** @class */ (function () {\n    function Segment(id, message, buffer, byteLength) {\n        if (byteLength === void 0) { byteLength = 0; }\n        this[Symbol.toStringTag] = 'Segment';\n        this.id = id;\n        this.message = message;\n        this.buffer = buffer;\n        this._dv = new DataView(buffer);\n        this.byteOffset = 0;\n        this.byteLength = byteLength;\n    }\n    /**\n     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return\n     * a pointer to freshly allocated space in another segment from the same message.\n     *\n     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.\n     * @returns {Pointer} A pointer to the newly allocated space.\n     */\n    Segment.prototype.allocate = function (byteLength) {\n        trace('allocate(%d)', byteLength);\n        var segment = this;\n        byteLength = util_1.padToWord(byteLength);\n        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8)\n            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));\n        if (!segment.hasCapacity(byteLength))\n            segment = segment.message.allocateSegment(byteLength);\n        var byteOffset = segment.byteLength;\n        segment.byteLength = segment.byteLength + byteLength;\n        trace('Allocated %x bytes in %s (requested segment: %s).', byteLength, this, segment);\n        return new pointers_1.Pointer(segment, byteOffset);\n    };\n    /**\n     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.\n     *\n     * @param {number} byteOffset The offset to write the word to.\n     * @param {Segment} srcSegment The segment to copy the word from.\n     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.\n     * @returns {void}\n     */\n    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {\n        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);\n        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    /**\n     * Quickly copy words from `srcSegment` into this one.\n     *\n     * @param {number} byteOffset The offset to start copying into.\n     * @param {Segment} srcSegment The segment to copy from.\n     * @param {number} srcByteOffset The start offset to copy from.\n     * @param {number} wordLength The number of words to copy.\n     * @returns {void}\n     */\n    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {\n        var dst = new Float64Array(this.buffer, byteOffset, wordLength);\n        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);\n        dst.set(src);\n    };\n    /**\n     * Quickly fill a number of words in the buffer with zeroes.\n     *\n     * @param {number} byteOffset The first byte to set to zero.\n     * @param {number} wordLength The number of words (not bytes!) to zero out.\n     * @returns {void}\n     */\n    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {\n        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);\n    };\n    /**\n     * Get the total number of bytes available in this segment (the size of its underlying buffer).\n     *\n     * @returns {number} The total number of bytes this segment can hold.\n     */\n    Segment.prototype.getCapacity = function () {\n        return this.buffer.byteLength;\n    };\n    /**\n     * Read a float32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat32 = function (byteOffset) {\n        return this._dv.getFloat32(byteOffset, true);\n    };\n    /**\n     * Read a float64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getFloat64 = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, true);\n    };\n    /**\n     * Read an int16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt16 = function (byteOffset) {\n        return this._dv.getInt16(byteOffset, true);\n    };\n    /**\n     * Read an int32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt32 = function (byteOffset) {\n        return this._dv.getInt32(byteOffset, true);\n    };\n    /**\n     * Read an int64 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt64 = function (byteOffset) {\n        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read an int8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getInt8 = function (byteOffset) {\n        return this._dv.getInt8(byteOffset);\n    };\n    /**\n     * Read a uint16 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint16 = function (byteOffset) {\n        return this._dv.getUint16(byteOffset, true);\n    };\n    /**\n     * Read a uint32 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint32 = function (byteOffset) {\n        return this._dv.getUint32(byteOffset, true);\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint64 = function (byteOffset) {\n        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));\n    };\n    /**\n     * Read a uint8 value out of this segment.\n     *\n     * @param {number} byteOffset The offset in bytes to the value.\n     * @returns {number} The value.\n     */\n    Segment.prototype.getUint8 = function (byteOffset) {\n        return this._dv.getUint8(byteOffset);\n    };\n    Segment.prototype.hasCapacity = function (byteLength) {\n        trace('hasCapacity(%d)', byteLength);\n        // capacity - allocated >= requested\n        return this.buffer.byteLength - this.byteLength >= byteLength;\n    };\n    /**\n     * Quickly check the word at the given offset to see if it is equal to zero.\n     *\n     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format\n     * and see if it's zero.\n     *\n     * Benchmark: http://jsben.ch/#/Pjooc\n     *\n     * @param {number} byteOffset The offset to the word.\n     * @returns {boolean} `true` if the word is zero.\n     */\n    Segment.prototype.isWordZero = function (byteOffset) {\n        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;\n    };\n    /**\n     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but\n     * more free space, otherwise all existing pointers to this segment will be hilariously broken.\n     *\n     * @param {ArrayBuffer} buffer The new buffer to use.\n     * @returns {void}\n     */\n    Segment.prototype.replaceBuffer = function (buffer) {\n        trace('replaceBuffer(%p)', buffer);\n        if (this.buffer === buffer)\n            return;\n        if (buffer.byteLength < this.byteLength)\n            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);\n        this._dv = new DataView(buffer);\n        this.buffer = buffer;\n    };\n    /**\n     * Write a float32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat32 = function (byteOffset, val) {\n        this._dv.setFloat32(byteOffset, val, true);\n    };\n    /**\n     * Write an float64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setFloat64 = function (byteOffset, val) {\n        this._dv.setFloat64(byteOffset, val, true);\n    };\n    /**\n     * Write an int16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt16 = function (byteOffset, val) {\n        this._dv.setInt16(byteOffset, val, true);\n    };\n    /**\n     * Write an int32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt32 = function (byteOffset, val) {\n        this._dv.setInt32(byteOffset, val, true);\n    };\n    /**\n     * Write an int8 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt8 = function (byteOffset, val) {\n        this._dv.setInt8(byteOffset, val);\n    };\n    /**\n     * Write an int64 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Int64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setInt64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint16 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint16 = function (byteOffset, val) {\n        this._dv.setUint16(byteOffset, val, true);\n    };\n    /**\n     * Write a uint32 value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint32 = function (byteOffset, val) {\n        this._dv.setUint32(byteOffset, val, true);\n    };\n    /**\n     * Write a uint64 value to the specified offset.\n     * TODO: benchmark other ways to perform this write operation.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {Uint64} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint64 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset + 0, val.buffer[0]);\n        this._dv.setUint8(byteOffset + 1, val.buffer[1]);\n        this._dv.setUint8(byteOffset + 2, val.buffer[2]);\n        this._dv.setUint8(byteOffset + 3, val.buffer[3]);\n        this._dv.setUint8(byteOffset + 4, val.buffer[4]);\n        this._dv.setUint8(byteOffset + 5, val.buffer[5]);\n        this._dv.setUint8(byteOffset + 6, val.buffer[6]);\n        this._dv.setUint8(byteOffset + 7, val.buffer[7]);\n    };\n    /**\n     * Write a uint8 (byte) value to the specified offset.\n     *\n     * @param {number} byteOffset The offset from the beginning of the buffer.\n     * @param {number} val The value to store.\n     * @returns {void}\n     */\n    Segment.prototype.setUint8 = function (byteOffset, val) {\n        this._dv.setUint8(byteOffset, val);\n    };\n    /**\n     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or\n     * `setFloat64` with a zero value.\n     *\n     * Benchmark: http://jsben.ch/#/dUdPI\n     *\n     * @param {number} byteOffset The offset of the word to set to zero.\n     * @returns {void}\n     */\n    Segment.prototype.setWordZero = function (byteOffset) {\n        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);\n    };\n    Segment.prototype.toString = function () {\n        return util_1.format('Segment_id:%d,off:%a,len:%a,cap:%a', this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);\n    };\n    return Segment;\n}());\nexports.Segment = Segment;\n\n//# sourceMappingURL=segment.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar int64_1 = require(\"./int64\");\nexports.Int64 = int64_1.Int64;\nvar uint64_1 = require(\"./uint64\");\nexports.Uint64 = uint64_1.Uint64;\n\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar util_1 = require(\"../util\");\nvar uint64_1 = require(\"./uint64\");\nvar trace = debug_1.default('capnp:int64');\ntrace('load');\n/**\n * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Int64 = /** @class */ (function (_super) {\n    tslib_1.__extends(Int64, _super);\n    function Int64() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Int64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Int64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    Int64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as an Int64 value.\n     *\n     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's\n     * complement form.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Int64} The string parsed as a 64-bit signed integer.\n     */\n    Int64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Int64.fromNumber(0);\n        var neg = source[0] === '-';\n        if (neg)\n            source = source.substr(1);\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        var val = new Int64(buf);\n        if (neg)\n            val.negate();\n        return val;\n    };\n    Int64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Int64.prototype.equals = function (other) {\n        return _super.prototype.equals.call(this, other);\n    };\n    Int64.prototype.inspect = function () {\n        return \"[Int64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    Int64.prototype.negate = function () {\n        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {\n            var v = (b[i] ^ 0xff) + carry;\n            b[i] = v & 0xff;\n            carry = v >> 8;\n        }\n    };\n    Int64.prototype.setValue = function (loWord, hiWord) {\n        var negate = false;\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            negate = hi < 0;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Int64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n        if (negate)\n            this.negate();\n    };\n    Int64.prototype.toHexString = function () {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        if (negate)\n            this.negate();\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = b[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        if (negate) {\n            this.negate();\n            hex = '-' + hex;\n        }\n        return hex;\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +/-Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Int64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var negate = b[7] & 0x80;\n        var x = 0;\n        var carry = 1;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            if (negate) {\n                v = (v ^ 0xff) + carry;\n                carry = v >> 8;\n                v = v & 0xff;\n            }\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return negate ? -Infinity : Infinity;\n        }\n        return negate ? -x : x;\n    };\n    return Int64;\n}(uint64_1.Uint64));\nexports.Int64 = Int64;\n\n//# sourceMappingURL=int64.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"../constants\");\nvar errors_1 = require(\"../errors\");\nvar util_1 = require(\"../util\");\nvar trace = debug_1.default('capnp:uint64');\ntrace('load');\n/**\n * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster\n * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.\n *\n * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!\n *\n * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.\n *\n * The value passed in as the source buffer is expected to be in little-endian format.\n */\nvar Uint64 = /** @class */ (function () {\n    /**\n     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert\n     * from other types or use a different offset into the buffer.\n     *\n     * Will throw if the buffer is not at least 8 bytes long.\n     *\n     * @constructor\n     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.\n     */\n    function Uint64(buffer) {\n        if (buffer.byteLength < 8)\n            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);\n        this.buffer = buffer;\n    }\n    Uint64.fromArrayBuffer = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source, offset, 8));\n        return new this(new Uint8Array(source.slice(offset, offset + 8)));\n    };\n    Uint64.fromDataView = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));\n    };\n    /**\n     * Parse a hexadecimal string in **big endian format** as a Uint64 value.\n     *\n     * @static\n     * @param {string} source The source string.\n     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.\n     */\n    Uint64.fromHexString = function (source) {\n        if (source.substr(0, 2) === '0x')\n            source = source.substr(2);\n        if (source.length < 1)\n            return Uint64.fromNumber(0);\n        if (source[0] === '-')\n            throw new RangeError('Source must not be negative.');\n        source = util_1.pad(source, 16);\n        if (source.length !== 16)\n            throw new RangeError('Source string must contain at most 16 hexadecimal digits.');\n        var bytes = source.toLowerCase().replace(/[^\\da-f]/g, '');\n        var buf = new Uint8Array(new ArrayBuffer(8));\n        for (var i = 0; i < 8; i++)\n            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);\n        return new Uint64(buf);\n    };\n    Uint64.fromNumber = function (source) {\n        var ret = new this(new Uint8Array(8));\n        ret.setValue(source);\n        return ret;\n    };\n    Uint64.fromUint8Array = function (source, offset, noCopy) {\n        if (offset === void 0) { offset = 0; }\n        if (noCopy === void 0) { noCopy = false; }\n        if (noCopy)\n            return new this(source.subarray(offset, offset + 8));\n        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));\n    };\n    Uint64.prototype.equals = function (other) {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== other.buffer[i])\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.inspect = function () {\n        return \"[Uint64 \" + this.toString(10) + \" 0x\" + this.toHexString() + \"]\";\n    };\n    /**\n     * Faster way to check for zero values without converting to a number first.\n     *\n     * @returns {boolean} `true` if the contained value is zero.\n     * @memberOf Uint64\n     */\n    Uint64.prototype.isZero = function () {\n        for (var i = 0; i < 8; i++) {\n            if (this.buffer[i] !== 0)\n                return false;\n        }\n        return true;\n    };\n    Uint64.prototype.setValue = function (loWord, hiWord) {\n        var lo = loWord;\n        var hi = hiWord;\n        if (hi === undefined) {\n            hi = lo;\n            hi = Math.abs(hi);\n            lo = hi % constants_1.VAL32;\n            hi = hi / constants_1.VAL32;\n            if (hi > constants_1.VAL32)\n                throw new RangeError(loWord + \" is outside Uint64 range\");\n            hi = hi >>> 0;\n        }\n        for (var i = 0; i < 8; i++) {\n            this.buffer[i] = lo & 0xff;\n            lo = i === 3 ? hi : lo >>> 8;\n        }\n    };\n    /**\n     * Convert to a native javascript number.\n     *\n     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!\n     *\n     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;\n     * otherwise out-of-range values are clamped to +Infinity.\n     * @returns {number} A numeric representation of this integer.\n     */\n    Uint64.prototype.toNumber = function (allowImprecise) {\n        var b = this.buffer;\n        var x = 0;\n        var i = 0;\n        var m = 1;\n        while (i < 8) {\n            var v = b[i];\n            x += v * m;\n            m *= 256;\n            i++;\n        }\n        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {\n            trace('Coercing out of range value %d to Infinity.', x);\n            return Infinity;\n        }\n        return x;\n    };\n    Uint64.prototype.valueOf = function () {\n        return this.toNumber(false);\n    };\n    Uint64.prototype.toArrayBuffer = function () {\n        return this.buffer.buffer;\n    };\n    Uint64.prototype.toDataView = function () {\n        return new DataView(this.buffer.buffer);\n    };\n    Uint64.prototype.toHexString = function () {\n        var hex = '';\n        for (var i = 7; i >= 0; i--) {\n            var v = this.buffer[i].toString(16);\n            if (v.length === 1)\n                v = '0' + v;\n            hex += v;\n        }\n        return hex;\n    };\n    Uint64.prototype.toString = function (radix) {\n        return this.toNumber(true).toString(radix);\n    };\n    Uint64.prototype.toUint8Array = function () {\n        return this.buffer;\n    };\n    return Uint64;\n}());\nexports.Uint64 = Uint64;\n\n//# sourceMappingURL=uint64.js.map\n","\"use strict\";\n/**\n * @author jdiaz5513\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// LINT: a lot of the util functions need the any type.\n/* tslint:disable:no-any no-unsafe-any */\nvar debug_1 = require(\"debug\");\nvar constants_1 = require(\"./constants\");\nvar errors_1 = require(\"./errors\");\nvar trace = debug_1.default('capnp:util');\ntrace('load');\n/**\n * Dump a hex string from the given buffer.\n *\n * @export\n * @param {ArrayBuffer} buffer The buffer to convert.\n * @returns {string} A hexadecimal string representing the buffer.\n */\nfunction bufferToHex(buffer) {\n    var a = new Uint8Array(buffer);\n    var h = [];\n    for (var i = 0; i < a.byteLength; i++)\n        h.push(pad(a[i].toString(16), 2));\n    return \"[\" + h.join(' ') + \"]\";\n}\nexports.bufferToHex = bufferToHex;\n/**\n * Throw an error if the provided value cannot be represented as a 32-bit integer.\n *\n * @export\n * @param {number} value The number to check.\n * @returns {number} The same number if it is valid.\n */\nfunction checkInt32(value) {\n    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32)\n        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);\n    return value;\n}\nexports.checkInt32 = checkInt32;\nfunction checkUint32(value) {\n    if (value < 0 || value > constants_1.MAX_UINT32)\n        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);\n    return value;\n}\nexports.checkUint32 = checkUint32;\n/**\n * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).\n *\n * @export\n * @param {Uint8Array} src A utf-8 encoded byte array.\n * @returns {string} A string representation of the byte array.\n */\nfunction decodeUtf8(src) {\n    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of\n    // stroke you may want to look away now.\n    var l = src.byteLength;\n    var dst = '';\n    var i = 0;\n    var cp = 0;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    while (i < l) {\n        a = src[i++];\n        if ((a & 128) === 0) {\n            cp = a;\n        }\n        else if ((a & 224) === 192) {\n            if (i >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            cp = ((a & 31) << 6) | (b & 63);\n        }\n        else if ((a & 240) === 224) {\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            cp = ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);\n        }\n        else if ((a & 248) === 240) {\n            if (i + 2 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            b = src[i++];\n            c = src[i++];\n            d = src[i++];\n            cp = ((a & 7) << 18) | ((b & 63) << 12) | ((c & 63) << 6) | (d & 63);\n        }\n        else {\n            throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n        }\n        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {\n            dst += String.fromCharCode(cp);\n        }\n        else {\n            // We must reach into the astral plane and construct the surrogate pair!\n            cp -= 0x00010000;\n            var hi = (cp >>> 10) + 0xd800;\n            var lo = (cp & 0x03ff) + 0xdc00;\n            if (hi < 0xd800 || hi > 0xdbff)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            dst += String.fromCharCode(hi, lo);\n        }\n    }\n    return dst;\n}\nexports.decodeUtf8 = decodeUtf8;\nfunction dumpBuffer(buffer) {\n    var b = buffer instanceof ArrayBuffer\n        ? new Uint8Array(buffer)\n        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);\n    var r = format('\\n=== buffer[%d] ===', byteLength);\n    for (var j = 0; j < byteLength; j += 16) {\n        r += \"\\n\" + pad(j.toString(16), 8) + \": \";\n        var s = '';\n        var k = void 0;\n        for (k = 0; k < 16 && j + k < b.byteLength; k++) {\n            var v = b[j + k];\n            r += pad(v.toString(16), 2) + \" \";\n            // Printable ASCII range.\n            s += v > 31 && v < 255 ? String.fromCharCode(v) : '·';\n            if (k === 7)\n                r += ' ';\n        }\n        r += \"\" + repeat((17 - k) * 3, ' ') + s;\n    }\n    r += '\\n';\n    if (byteLength !== b.byteLength) {\n        r += format('=== (truncated %d bytes) ===\\n', b.byteLength - byteLength);\n    }\n    return r;\n}\nexports.dumpBuffer = dumpBuffer;\n/**\n * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.\n *\n * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.\n *\n * @export\n * @param {string} src The input string.\n * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.\n */\nfunction encodeUtf8(src) {\n    var l = src.length;\n    var dst = new Uint8Array(new ArrayBuffer(l * 4));\n    var j = 0;\n    for (var i = 0; i < l; i++) {\n        var c = src.charCodeAt(i);\n        if (c <= 0x7f) {\n            dst[j++] = c;\n        }\n        else if (c <= 0x07ff) {\n            dst[j++] = 192 | (c >>> 6);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else if (c <= 0xd7ff || c >= 0xe000) {\n            dst[j++] = 224 | (c >>> 12);\n            dst[j++] = 128 | ((c >>> 6) & 63);\n            dst[j++] = 128 | ((c >>> 0) & 63);\n        }\n        else {\n            // Make sure the surrogate pair is complete.\n            /* istanbul ignore next */\n            if (i + 1 >= l)\n                throw new RangeError(errors_1.RANGE_INVALID_UTF8);\n            // I cast thee back into the astral plane.\n            var hi = c - 0xd800;\n            var lo = src.charCodeAt(++i) - 0xdc00;\n            var cp = ((hi << 10) | lo) + 0x00010000;\n            dst[j++] = 240 | (cp >>> 18);\n            dst[j++] = 128 | ((cp >>> 12) & 63);\n            dst[j++] = 128 | ((cp >>> 6) & 63);\n            dst[j++] = 128 | ((cp >>> 0) & 63);\n        }\n    }\n    return dst.subarray(0, j);\n}\nexports.encodeUtf8 = encodeUtf8;\n/**\n * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string\n * concatenation up front. Precision is supported for floating point numbers.\n *\n * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.\n * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string\n * are ignored.\n * @returns {string} The formatted string.\n */\nfunction format(s) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var n = s.length;\n    var arg;\n    var argIndex = 0;\n    var c;\n    var escaped = false;\n    var i = 0;\n    var leadingZero = false;\n    var precision;\n    var result = '';\n    function nextArg() {\n        return args[argIndex++];\n    }\n    function slurpNumber() {\n        var digits = '';\n        while (/\\d/.test(s[i])) {\n            digits += s[i++];\n            c = s[i];\n        }\n        return digits.length > 0 ? parseInt(digits, 10) : null;\n    }\n    for (; i < n; ++i) {\n        c = s[i];\n        if (escaped) {\n            escaped = false;\n            if (c === '.') {\n                leadingZero = false;\n                c = s[++i];\n            }\n            else if (c === '0' && s[i + 1] === '.') {\n                leadingZero = true;\n                i += 2;\n                c = s[i];\n            }\n            else {\n                leadingZero = true;\n            }\n            precision = slurpNumber();\n            switch (c) {\n                case 'a':// number in hex with padding\n                    result += '0x' + pad(parseInt(nextArg(), 10).toString(16), 8);\n                    break;\n                case 'b':// number in binary\n                    result += parseInt(nextArg(), 10).toString(2);\n                    break;\n                case 'c':// character\n                    arg = nextArg();\n                    if (typeof arg === 'string' || arg instanceof String) {\n                        result += arg;\n                    }\n                    else {\n                        result += String.fromCharCode(parseInt(arg, 10));\n                    }\n                    break;\n                case 'd':// number in decimal\n                    result += parseInt(nextArg(), 10);\n                    break;\n                case 'f':// floating point number\n                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));\n                    result += leadingZero ? tmp : tmp.replace(/^0/, '');\n                    break;\n                case 'j':// JSON\n                    result += JSON.stringify(nextArg());\n                    break;\n                case 'o':// number in octal\n                    result += '0' + parseInt(nextArg(), 10).toString(8);\n                    break;\n                case 's':// string\n                    result += nextArg();\n                    break;\n                case 'x':// lowercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16);\n                    break;\n                case 'X':// uppercase hexadecimal\n                    result += '0x' + parseInt(nextArg(), 10).toString(16).toUpperCase();\n                    break;\n                default:\n                    result += c;\n                    break;\n            }\n        }\n        else if (c === '%') {\n            escaped = true;\n        }\n        else {\n            result += c;\n        }\n    }\n    return result;\n}\nexports.format = format;\n/**\n * Return the thing that was passed in. Yaaaaawn.\n *\n * @export\n * @template T\n * @param {T} x A thing.\n * @returns {T} The same thing.\n */\nfunction identity(x) {\n    return x;\n}\nexports.identity = identity;\nfunction pad(v, width, pad) {\n    if (pad === void 0) { pad = '0'; }\n    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;\n}\nexports.pad = pad;\n/**\n * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.\n *\n * @export\n * @param {number} size The number to pad.\n * @returns {number} The padded number.\n */\nfunction padToWord(size) {\n    return (size + 7) & ~7;\n}\nexports.padToWord = padToWord;\n/**\n * Repeat a string n times. Shamelessly copied from lodash.repeat.\n *\n * @param {number} times Number of times to repeat.\n * @param {string} str The string to repeat.\n * @returns {string} The repeated string.\n */\nfunction repeat(times, str) {\n    var out = '';\n    var n = times;\n    var s = str;\n    if (n < 1 || n > Number.MAX_VALUE)\n        return out;\n    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    do {\n        if (n % 2)\n            out += s;\n        n = Math.floor(n / 2);\n        if (n)\n            s += s;\n    } while (n);\n    return out;\n}\nexports.repeat = repeat;\n// Set up custom debug formatters.\n/* tslint:disable:no-string-literal */\n/* istanbul ignore next */\ndebug_1.default.formatters['h'] = function (v) { return v.toString('hex'); };\n/* istanbul ignore next */\ndebug_1.default.formatters['x'] = function (v) { return \"0x\" + v.toString(16); };\n/* istanbul ignore next */\ndebug_1.default.formatters['a'] = function (v) { return \"0x\" + pad(v.toString(16), 8); };\n/* istanbul ignore next */\ndebug_1.default.formatters['X'] = function (v) { return \"0x\" + v.toString(16).toUpperCase(); };\n/* tslint:enable:no-string-literal */\n\n//# sourceMappingURL=util.js.map\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).\n */\n\n/* tslint:disable */\n\nimport * as capnp from \"capnp-ts\";\nimport { ObjectSize as __O, Struct as __S } from 'capnp-ts';\nexport const _capnpFileId = \"dbb9ad1f14bf0b36\";\nexport class Date extends __S {\n    static readonly _capnp = { displayName: \"Date\", id: \"ef29c66fa74a8c93\", size: new __O(8, 0) };\n    getYear(): number { return __S.getInt16(0, this); }\n    setYear(value: number): void { __S.setInt16(0, value, this); }\n    getMonth(): number { return __S.getUint8(2, this); }\n    setMonth(value: number): void { __S.setUint8(2, value, this); }\n    getDay(): number { return __S.getUint8(3, this); }\n    setDay(value: number): void { __S.setUint8(3, value, this); }\n    toString(): string { return \"Date_\" + super.toString(); }\n}\nexport class DateArr extends __S {\n    static readonly _capnp = { displayName: \"DateArr\", id: \"f74dc6379e812e3f\", size: new __O(0, 1) };\n    static _Value: capnp.ListCtor<Date>;\n    adoptValue(value: capnp.Orphan<capnp.List<Date>>): void { __S.adopt(value, __S.getPointer(0, this)); }\n    disownValue(): capnp.Orphan<capnp.List<Date>> { return __S.disown(this.getValue()); }\n    getValue(): capnp.List<Date> { return __S.getList(0, DateArr._Value, this); }\n    hasValue(): boolean { return !__S.isNull(__S.getPointer(0, this)); }\n    initValue(length: number): capnp.List<Date> { return __S.initList(0, DateArr._Value, length, this); }\n    setValue(value: capnp.List<Date>): void { __S.copyFrom(value, __S.getPointer(0, this)); }\n    toString(): string { return \"DateArr_\" + super.toString(); }\n}\nDateArr._Value = capnp.CompositeList(Date);\n","/**\n * File: c:\\Users\\35327\\Githubs\\ts-template\\src\\index.ts\n * Project: c:\\Users\\35327\\Githubs\\ts-template\n * Created Date: Friday, June 29th 2018, 12:01:19 am\n * @author: liaodh\n * @summary: short description for the file\n * -----\n * Last Modified: Friday, June 29th 2018, 7:39:30 pm\n * Modified By: liaodh\n * -----\n * Copyright (c) 2018 jiguang\n */\nimport * as capnp from 'capnp-ts';\nimport { Date, DateArr } from './date.capnp';\n\n\nexport function loadMessage(buffer: ArrayBuffer) {\n    const message = new capnp.Message(buffer);\n    return message.getRoot(Date);\n}\n\nlet buffer = new ArrayBuffer(Date._capnp.size.dataByteLength);\nlet message = new capnp.Message(buffer, false, true)\n\nlet date = capnp.Message.initRoot(Date, message);\n\n\ndate.setYear(1992)\ndate.setMonth(10)\ndate.setDay(25)\n\n// Date._capnp\n// const q = new Date(buffer,0);\n// q.segment.\n\n//     capnp.Message.toArrayBuffer(new capnp.Message())\nlet q = loadMessage(date.segment.message.toPackedArrayBuffer())\n\nconsole.log(q.getYear())\n\nlet buffer2 = new ArrayBuffer(1000);\nlet message2 = new capnp.Message(buffer2, false, true)\nconsole.log('--------')\nlet arr = capnp.Message.initRoot(DateArr, message2);\n\narr.initValue(0);\narr.getValue().set(0, q)\n\nconsole.log(arr.getValue().get(0).getYear());\n\nlet q2 = arr.segment.message.toPackedArrayBuffer()\nconst qq2 = new capnp.Message(q2);\n\n// console.log(qq2.getRoot(DateArr).getValue().get(0).getYear());\n"],"sourceRoot":""}